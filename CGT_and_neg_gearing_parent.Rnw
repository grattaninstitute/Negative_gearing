% !TeX program = pdflatex
\documentclass{grattan}

\title{Negative gearing and the capital gains discount}
\author{John Daley and Danielle Wood}

\addbibresource{bibliography.bib}
\addbibresource{bibliography2.bib} % r packages

\input{CGT-NG-sections/preamble}
<<MODELLING-PARAMETERS, echo=FALSE>>=
new.discount <- 0.25  # proposed CGT
TARGET.FY <- "2015-16"
use.sample.fy <- "2013-14"  # deprecated
latest.sample.fy <- "2013-14"
@


\begin{document}
%\clearpage
%\chapter{Distribution of negative gearing}
<<knitrOpts, echo=FALSE, results='hide'>>=
library(knitr)
.finished <- FALSE
file.create("CGT_and_neg_gearing_parent-CHUNKTIMINGS.txt")
knit_hooks$set(timeit = function(before) {
    if (before) {
      .current.time <<- Sys.time()
    } else {
      .duration <- formatC(round(difftime(Sys.time(), .current.time, units = "secs"), 1), 
                           # ensure one decimal place, right-aligned (width = 5)
                           format = "f", flag = "#", digits = 1, width = 5)
      if(!.finished)
        write(
          paste0(.duration, 
                 "\t", 
                 knitr::opts_current$get(name = "label")),
          file = "CGT_and_neg_gearing_parent-CHUNKTIMINGS.txt",
          ncolumns = 1,
          append = TRUE)
    }
})


library(devEMF)
START.TIME <- Sys.time()
my_pdf <- function(file, width, height){
  pdf(file = file, width, height = height)
}

my_emf <- function(file, width, height){
  emf(file = file, width = width, height = height)
}

# knitr chunk opts
# fig.width must = out.width and same for *.height
knitr::opts_chunk$set(fig.width=11.000, 
                      fig.height=7.00, 
                      out.width="11.000in", 
                      out.height="7.00in", 
                      fig.show='hide',
                      echo=FALSE,
                      fig.path= atlas <- "CGT-NG-atlas/",
                      message=FALSE, 
                      warning=FALSE, 
                      timeit =TRUE
                      #
                      ,error=FALSE
                      ,results='hide'
                      ,cache=FALSE
                      ,dev=c('my_pdf', 'my_emf', 'png')
                      ,fig.ext = c("pdf", 'emf', "png")
)
@

<<loadPackages>>=
library(knitr)
library(data.table)
library(dplyr)
library(devEMF)
library(gridExtra)
library(ggplot2)
library(scales)
library(directlabels)
library(grattan)
library(xtable)
library(readxl)
library(openxlsx)
library(readr)
library(rsdmx)
library(httr)
library(zoo)
library(survey)
library(foreign)
library(Hmisc)
library(expm)
library(devtools)
library(tidyr)
library(magrittr)
library(taxstats)
library(testthat)
@

<<downloadGrattex>>=
overwrite_grattex <- (!file.exists("grattan.cls") || (difftime(Sys.time(), file.info("grattan.cls")$ctime, units = "days") > 2))
if (overwrite_grattex){
  GET(url = "https://raw.githubusercontent.com/HughParsonage/grattex/master/grattan.cls", 
      write_disk("grattan.cls", overwrite = TRUE))
}
@

<<packcageCitation>>=
# Select packages to cite:
citPkgs <- names(sessionInfo()$otherPkgs)
# Write the bibtex file:
knitr::write_bib(citPkgs, file="bibliography2.bib")      
package_cite_input <- paste0("\\nocite{", paste0(paste0("R-", citPkgs), collapse=","), "}")
write(package_cite_input, file = "package_cite_input.tex")
@
% citations
\input{package_cite_input}

% \textheight may be quite small for flushbottom
% \raggedbottom

<<latex_percent>>=
latex_percent <- function (x, percentage_symbol = "~percent") {
    x <- plyr::round_any(x, scales:::precision(x)/100)
    stringr::str_c(comma(x * 100), percentage_symbol)
}
@

<<select_which_>>=
select_which_ <- function(.data, Which, .and.dots) {
  Which <- match.fun(Which)
  if (!missing(.and.dots)) {
    select_(.data, .dots = c(names(.data)[sapply(.data, Which)], .and.dots))
  } else {
    select_(.data, .dots = names(.data)[sapply(.data, Which)])
  }
}
@



<<xtable-formatting>>=
# bold column names
boldxt <- function(x, sanitize = TRUE) {
  # Replace $ without \\
  x <- ifelse(grepl("((?<!\\\\)\\$)", x, perl = TRUE), gsub("$", "\\$", x, fixed = TRUE), x)
  paste('{\\textbf{',x,'}}', sep ='')
}
options("xtable.sanitize.colnames.function" = function(x) boldxt(x))
@

<<load_sample_file>>=
sample_file <- sample_files_all[fy.year == use.sample.fy]
@

<<create-age-imp>>=
sample_file <- merge(sample_file, age_range_decoder, by = "age_range")

set.seed(48031)
sample_file %<>%
  group_by(age_range_description) %>%
  mutate(min_age = ifelse(grepl("to", age_range_description), 
                          as.numeric(stringr::str_extract(age_range_description, "^[0-9]{2}")), 
                          ifelse(grepl("70", age_range_description),
                                 70, 
                                 15)),
         max_age = min_age + 5, 
         age_imp = runif(n(), min_age, max_age)) 
@

<<target_sample_file>>=
keep.names <- names(sample_file)
target_sample_file <- 
  sample_file %>%
  project_to(to_fy = TARGET.FY, fy.year.of.sample.file = latest.sample.fy) %>%
  select_(.dots = keep.names)
rm(keep.names)
@

<<Import-HILDA, cache=TRUE>>=
hilda_w14_hh <- 
  foreign::read.dta("HILDA/Wave14/Household_n140c.dta")
@

<<Import-HILDA-ep, cache=TRUE>>=
hilda_w14_ep <- 
  foreign::read.dta("HILDA/Wave14/Eperson_n140c.dta")
@

<<Import-HILDA-rp, cache=TRUE>>=
hilda_w14_rp <- 
  foreign::read.dta("HILDA/Wave14/Rperson_n140c.dta")
@


%%% Costings analysis

<<Determine_future_rental_deductions>>=
historical.interest.losses <- 
  sample_files_all %>%
  group_by(year = fy2yr(fy.year)) %>%
  summarise(tot.rent_interest_deds = sum(as.numeric(Rent_int_ded_amt * WEIGHT)))

total.investor.loans <- 
  read_excel("ABS_Household_financing.xlsx", sheet = "Investment_loans_outstanding") %>%
  group_by(year = lubridate::year(Date)) %>%
  summarise(loans_amt = mean(Investment_housing_all_deposit_taking_institutions) * 10^6)

rba_interest <- 
  read_excel("RBA_Household_interest_rates.xlsx", sheet = "Housing_lending_rates") %>%
  group_by(year = lubridate::year(Date)) %>%
  summarise(mean.i = mean(Housing_lending_rate)/100)

interest_losses <-
  merge(total.investor.loans, rba_interest) %>%
  merge(., historical.interest.losses, all.x = TRUE) %>%
  mutate(interestXloans = mean.i * loans_amt)

# Good enough 
# plot(lm(tot.rent_interest_deds ~ interestXloans, data = interest_losses))
rental.losses <-
interest_losses[!complete.cases(interest_losses), ] %>%
  do({
    model <- lm(tot.rent_interest_deds ~ interestXloans, data = interest_losses)
    pred <- predict(model, newdata = .[c("interestXloans")])
    data.frame(., pred)
  }) %>%
  mutate(tot.rent_interest_deds = pred) %>%
  select(year, tot.rent_interest_deds) %>%
  rbind(select(interest_losses, year, tot.rent_interest_deds)) %>%
  filter(!is.na(tot.rent_interest_deds)) %>%
  arrange(year) %>% 
  mutate(ratio = tot.rent_interest_deds/tot.rent_interest_deds[which(year == 2013)])

# It's about 1 for 2015, (certainly if se is taken into acct), so I'm not going to bother

@

<<cost-new-CGT-discount>>=
revenue_CGT_discount <- function(CGT.discount = new.discount, .old.discount = 0.50){
    target_sample_file %>%
    mutate(new_Net_CG_amt = (Net_CG_amt / (1 - .old.discount)) * (1 - CGT.discount),
           new_Tot_inc_amt = Tot_inc_amt - Net_CG_amt + new_Net_CG_amt,
           new_Tot_ded_amt = Tot_ded_amt,  # no change
           new_Taxable_Income = pmaxC(new_Tot_inc_amt - new_Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed, 0),
           old_tax = income_tax(Taxable_Income, fy.year = fy.year, age = age_imp),
           new_tax = income_tax(new_Taxable_Income, fy.year = fy.year, age = age_imp),
           tax_increase = new_tax - old_tax)
}
@

<<revenue_abolish_NG>>=
revenue_abolish_NG <- function(fy.year = "2016-17"){
  sample_file_1314 %>%
    select(-contains("MCS")) %>%  # project not good
    project_to(fy.year, fy.year.of.sample.file = use.sample.fy) %>%
    mutate(new_Tot_inc_amt = Tot_inc_amt - Net_rent_amt + pmaxC(Net_rent_amt, 0),
           new_Taxable_Income = pmaxC(new_Tot_inc_amt - Tot_ded_amt - NPP_loss_claimed - PP_loss_claimed, 0),
           prev_tax = income_tax(Taxable_Income, fy.year = "2015-16"), 
           new_tax  = income_tax(new_Taxable_Income, fy.year = "2015-16"), 
           tax_increase = new_tax - prev_tax)
}

@

<<cgt_discount_density>>=
cgt_discount_distribution <- 
  sample_file %>%
  filter(Tot_CY_CG_amt > 0) %>%
  group_by(apparent_discount = round((1 - Net_CG_amt / Tot_CY_CG_amt) * 4) / 4) %>%
  summarise(value = sum(Tot_CY_CG_amt)) %>%
  ungroup %>%
  mutate(density = value / sum(value)) %>%
  arrange(apparent_discount) %>% 
  mutate(cumdensity = cumsum(density))

probNoDiscount <- 
  cgt_discount_distribution %>% 
  filter(apparent_discount == 0) %$%
  cumdensity
@

<<revenue_quarantine_NG_year0>>=
# new.discount <- 0.25  # proposed CGT
# TARGET.FY <- "2015-16"
# use.sample.fy <- "2013-14"
revenue_quarantine_NG_year0 <- function(sample_file = sample_file_1314, new_CGT_discount = new.discount, sample_file_fy_year = use.sample.fy, .old.discount = 0.50){
  
  if (sample_file_fy_year != "2013-14"){
    stop("Correct sample_file year")
  } 
  
  round_cols <- function(column){
    if (!is.numeric(column)){
      column
    } else {
      round(column, 2)
    }
  }
  target_sample_file %>%
    # cosmetic for debugging
    mutate_each(funs(round_cols)) %>%
    
    # We need to work out how much the discount will change Net_CG_amt.
    # We use the density of the apparent_discount to randomly 
    # assign a new discount rate.  Note that this does not 
    # adequately take into account the impact of capital losses
    mutate(
      new_Net_CG_amt = ifelse(runif(n()) < probNoDiscount, 
                              Net_CG_amt, 
                              (Net_CG_amt / (1 - .old.discount)) * (1 - new_CGT_discount))) %>%
    
    mutate(
      # Other_Income means income (possibly -ve) that is 
      # not salary, CG, or rental
      quarantined_income = Sw_amt + Alow_ben_amt + ETP_txbl_amt,
      # Other_Income may be -ve
      Other_Income = round(Tot_inc_amt - Net_CG_amt + new_Net_CG_amt - quarantined_income - Net_rent_amt, 2),
      new_Tot_inc_amt = quarantined_income + ifelse(Other_Income <= 0, 
                                                    # Nothing for rent to deduct against, 
                                                    # but Other_Income is permitted to be -ve
                                                    Other_Income,
                                                    # If Net_rent is negative it is allowed to 
                                                    # reduce Other income till exhausted. If
                                                    # it is positive, pmaxC has no effect, as desired.
                                                    pmaxC(Other_Income + Net_rent_amt, 0))
    ) %>% 
    mutate(
      # This is the standard calculation for taxable income
      new_Taxable_Income = pmaxC(new_Tot_inc_amt - Tot_ded_amt - NPP_loss_claimed - PP_loss_claimed, 0),
      prev_tax = income_tax(Taxable_Income, fy.year = "2013-14"), 
      post_tax = income_tax(new_Taxable_Income, fy.year = "2013-14"), 
      tax_increase = post_tax - prev_tax
    ) 
}
@

<<revenue_quarantine_NG>>=
# new.discount <- 0.25  # proposed CGT
# TARGET.FY <- "2015-16"
# use.sample.fy <- "2013-14"
# Z is ~ number of iterations of the model for age_based = FALSE
revenue_quarantine_NG <- function(sample_file = sample_file_1314, new_CGT_discount = new.discount, sample_file_fy_year = use.sample.fy, target_fy = TARGET.FY, age_based = TRUE, Z = 20){
  if (sample_file_fy_year != "2013-14"){
    stop("You must correct the sample_file year")
  }
  
  if (!age_based){
    probNG_if_investor <- 
      sample_file %>%
      filter(Gross_rent_amt > 0) %$%
      mean(Net_rent_amt < 0)
  
    M4 <- matrix(0, nrow = 2*Z, ncol = 2*Z)
    M4[row(M4) == col(M4) - 2] <- probNG_if_investor
    M4[row(M4) == col(M4) - 1] <- 1 - probNG_if_investor
    M4[row(M4) %% 2 == 0] <- 0
    M4[row(M4) %% 2 == 0 & row(M4) == col(M4)] <- 1
    M4[2*Z - 1, 2*Z] <- 1
    
    stopifnot(all(rowSums(M4) == 1))
    
    P <- M4 %^% (Z + 1)
    
    init <- c(1,rep(0, Z - 1))
    
    # even entries of P are the absorbing states
    E <- init %*% P[c(TRUE, FALSE),c(FALSE,TRUE)]
    
    accumulator <- 
      data.table(rand = cumsum(E[1,]), 
                 loss_multiplier = 1:(Z)) %>%
      setkey(rand)
    
    forecast_loss_multiple <- function(.data){
      setkey(.data, rand) %>%
        accumulator[., roll = -Inf]
    }
  } else {
    
    # age based-method
    # q ~ probNG_if_investor
    q_by_age <- 
      sample_file %>%
      filter(Gross_rent_amt > 0) %>%
      group_by(age_range) %>%
      summarise(q = mean(Net_rent_amt < 0))
    
    q_by_integer_age <- 
      data.table(age_range = rep(q_by_age$age_range, each = 5)) %>% 
      merge(q_by_age, by = "age_range") %>%
      merge(age_range_decoder) %>%
      group_by(age_range_description) %>%
      mutate(min_age = ifelse(grepl("to", age_range_description), 
                              as.numeric(stringr::str_extract(age_range_description, "^[0-9]{2}")), 
                              ifelse(grepl("70", age_range_description),
                                     70, 
                                     15)), 
             age = min_age - 1  + 1:n()) %>%
      ungroup %>%
      arrange(age) %>%
      select(-age_range, age_range_description, -min_age) %>%
      select(age, q)
    
    # We want a wide data frame which shows, for each
    # age, the probability of going from n_ahead to n_ahead + 1
    # so [i, j] represents the probability that a person aged i
    # who *will* negative gear for at least j years will negatively gear
    # in the year j + 1.
    
    # All the information to produce this dataframe/matrix is contained in q
    # so we just need to extract it. 
    # We keep applying lead until just before there will be a column of pure NA.
    j <- 1
    q_by_integer_age %<>% rename(q1 = q)
    while (TRUE){  
      j <- j + 1
      mutate_call = lazyeval::interp(~lead(b), b = as.name(paste0("q", j - 1)))
      q_by_integer_age %<>% mutate_(.dots = setNames(list(mutate_call), paste0("q", j)))
      
      # breaker:
      if (any(colSums(is.na(q_by_integer_age)) == nrow(q_by_integer_age) - 1)){
        # We're done. Before we `break;` let's clean up.
        # We assume that people persist in this model beyond 75
        na_locf <- function(x){
          na.locf(x, na.rm = FALSE)
        }
        
        q_by_integer_age %<>%
          mutate_each(funs(na_locf))
        break
      }
    }
    
    q_by_integer_age_long <- 
      q_by_integer_age %>%
      gather(n_ahead, prob_NG_if_investor, -age) %>%
      mutate(n_ahead = as.numeric(gsub("q", "", n_ahead))) %>%
      arrange(age, n_ahead)
    
    E_by_age <- function(the_age){
      probNG_if_investor <- 
        q_by_integer_age_long %>%
        filter(age == the_age) %$%
        prob_NG_if_investor
      
      Z <- length(probNG_if_investor)
      
      # Construct a matrix as before: 
      # odd states represent continuing negative gearing
      # even states are absorbing
      #
      # The idea is that once an individual stop negative gearing
      # that person never negative gears and their accumulated losses
      # are those thitherto accumulated. 
      MA <- matrix(0, nrow = 2*Z, ncol = 2*Z)
      # if still NG, advance
      MA[row(MA) == col(MA) - 2] <- rep(probNG_if_investor, each = 2)[-c(1, 2*Z)]  ## dropped indices fall off the 'north' and 'east' the matrix
      # else fall into absorbing state
      MA[row(MA) == col(MA) - 1] <- rep(1 - probNG_if_investor, each = 2)[-c(2*Z)]
      
      # even entires are absorbing
      MA[row(MA) %% 2 == 0] <- 0
      MA[row(MA) %% 2 == 0 & row(MA) == col(MA)] <- 1
      
      # Final state hack to ensure stochastic.
      # We take the last state as absorbing, even if the person is (by some miracle) still NG.
      MA[2*Z - 1, 2*Z] <- 1
      
      # MA must be stochastic
      stopifnot(all(rowSums(MA) == 1))
      
      P <- MA %^% (Z + 1)
      
      init <- c(1, rep(0, Z - 1))
      
      # even entries of P are the absorbing states
      E <- init %*% P[c(TRUE, FALSE),c(FALSE,TRUE)]
      
      data.table(
        age = rep(the_age, Z),
        loss_multiplier = 1:Z, 
        E = as.numeric(t(E))
      )
    }
    
    accumulator_by_age <- 
      lapply(unique(q_by_integer_age_long$age), E_by_age) %>% 
      rbindlist(.) %>%
      group_by(age) %>%
      mutate(rand = cumsum(E)) %>%
      setkey(age, rand)
    
    forecast_loss_multiple <- function(.data){
      setkey(.data, age, rand) %>%
        accumulator_by_age[., roll = -Inf]
    }
    
  }
  
  target_sample_file %>%
    # mutate_each(funs(round_cols)) %>%
    
    # We need to work out how much the discount will change Net_CG_amt.
    # We use the density of the apparent_discount to randomly 
    # assign a new discount rate.  Note that this does not 
    # adequately take into account the impact of capital losses
    mutate(
      new_Net_CG_amt = Net_CG_amt * ifelse(runif(n()) < probNoDiscount, 
                                           1, 
                                           (1 - new_CGT_discount) / 0.50)) %>%
    
    # Excluding CG for the moment, we create a new total income amount 
    # which quarantines salary from NG.  Rental losses may be deducted 
    # against investment income (including capital gains).  However, 
    # we assume that they are deducted against capital gains only
    # in the future
    mutate(
      # Other_Income means income (possibly -ve) that is 
      # not salary, CG, or rental
      quarantined_income = Sw_amt + Alow_ben_amt + ETP_txbl_amt,
      Other_Income = round(Tot_inc_amt - quarantined_income - Net_CG_amt - Net_rent_amt, 2),
      new_Tot_inc_amt_no_CG = quarantined_income + ifelse(Other_Income <= 0, 
                                                          # Nothing for rent to deduct against, 
                                                          # but Other_Income is permitted to be -ve
                                                          Other_Income,
                                                          # Net_rent is negative and is allowed to 
                                                          # reduce Other income till exhausted
                                                          pmaxC(Other_Income + Net_rent_amt, 0))
    ) %>% 
    mutate(
      # should be positive
      accumulated_losses_year_0 = -1 * ifelse(Net_rent_amt >= 0, 
                                              0, 
                                              pminC(Other_Income + Net_rent_amt, 0)), 
      new_Tot_inc_amt = new_Tot_inc_amt_no_CG + Net_CG_amt
    ) %>% 
    mutate(rand = runif(n()), 
           age = floor(age_imp)) %>%
    forecast_loss_multiple %>%
    
    mutate(
      accumulated_losses_year_Z = accumulated_losses_year_0 * loss_multiplier
    ) %>% 
    mutate(
      # This is the standard calculation for taxable income
      new_Taxable_Income_yearZ = pmaxC(pmaxC(Other_Income + new_Net_CG_amt - accumulated_losses_year_Z, 
                                             0) + quarantined_income - Tot_ded_amt - NPP_loss_claimed - PP_loss_claimed, 
                                       0),
      new_Taxable_Income_year0 = pmaxC(pmaxC(Other_Income + new_Net_CG_amt, 
                                             0) + quarantined_income - Tot_ded_amt - NPP_loss_claimed - PP_loss_claimed, 
                                       0)) %>%
    mutate(
      prev_tax = income_tax(Taxable_Income, fy.year = "2013-14"), 
      post_tax_yearZ = income_tax(new_Taxable_Income_yearZ, fy.year = "2013-14"), 
      post_tax_year0 = income_tax(new_Taxable_Income_year0, fy.year = "2013-14"),
      tax_increase = post_tax_yearZ - prev_tax, 
      tax_increase_year0 = post_tax_year0 - prev_tax
    )
}
@

<<henry_taxstats>>=
henry_taxstats <- function(new.discount){
  target_sample_file %>%
    mutate(new_capital_gains = 2 * Net_CG_amt * (1 - new.discount), 
           new_net_rent = Net_rent_amt * (1 - new.discount * (Net_rent_amt < 0)), 
           new_investment_lss = Net_fincl_invstmt_lss_amt * (1 - new.discount), 
           new_Taxable_Income = pmaxC(Taxable_Income - Net_CG_amt + new_capital_gains - Net_rent_amt + new_net_rent - Net_fincl_invstmt_lss_amt + new_investment_lss, 0), 
           prev_tax = income_tax(Taxable_Income, fy.year = TARGET.FY), 
           post_tax = income_tax(new_Taxable_Income, fy.year = TARGET.FY), 
           tax_increase = post_tax - prev_tax)
}
@

<<Summary-chunk, results='hide', eval = TRUE>>=
# Our proposal
policy <- revenue_quarantine_NG(sample_file = sample_file_1314, 
                                new_CGT_discount = 0.25, 
                                sample_file_fy_year = "2013-14", 
                                target_fy = TARGET.FY, 
                                Z = 50)

policy_year0 <- revenue_quarantine_NG_year0()
# The Henry proposal
policy_align_gains_and_losses <- henry_taxstats(new.discount = new.discount)

policy_reduce_CGT <- revenue_CGT_discount()

write(x = c(
  paste("Cost of policy ($bn) by policy option with CGT discount set at", percent(new.discount), TARGET.FY),
  "===================================="),
  file = "Summary_table.txt")

print_cost <- function(the.policy, bn = TRUE){
  formatC(round(the.policy$WEIGHT[1] * sum(the.policy$tax_increase) / 1e9, 1), width = 4, digits = 1, flag = "#", format = "f")
}

cost_of <- function(the.policy){
  the.policy$WEIGHT[1] * sum(the.policy$tax_increase)
}

cost_of_NG_only <- 
  cost_of(policy) - cost_of(policy_reduce_CGT)

write(x = c(
  print_cost(policy_year0), "Quarantine NG losses and reduce CGT discount (Year 0)", 
  print_cost(policy), "Quarantine NG losses and reduce CGT discount", 
  print_cost(policy_reduce_CGT), "Reduce CGT discount", 
  # diff_just_due_NG, "Just quarantine losses", 
  # diff_just_due_NG_year0, "Just quarantine losses (year 0)",
  print_cost(policy_align_gains_and_losses), "Henry proposal"
      ),
  file = "Summary_table.txt",
  append = TRUE,
  ncolumns = 2
  )
@

<<CostofNGtotal>>=
sample_file_1213 %>%
  mutate(new_tax = income_tax(Taxable_Income - pmin(0, Net_rent_amt), fy.year = "2012-13"),
         diff = new_tax - income_tax(Taxable_Income, fy.year = "2012-13")) %$%
  sum(diff) * 50 / 1e9  ->
  NG.tx.exp

NG.tx.exp <- round(NG.tx.exp, 1)
@

\newlength{\overviewextra}
\setlength{\overviewextra}{4pt}
\addtolength{\columnsep}{\overviewextra}
\begin{overview*}[-35pt]
Australia's tax system aims to encourage investment. Capital gains are not taxed at marginal rates of income tax. Negatively geared investors -- those who borrow to invest, usually in housing -- can deduct their annual losses from wage and salary income. 

However, these arrangements do not sufficiently balance the competing considerations. They should be wound back as the Commonwealth Government inevitably turns to revenue measures to address its structural budget problems. 

The tax on capital gains is discounted to promote savings and entrepreneurship. A theoretically ideal tax treatment would only tax returns higher than the risk-free rate. But this idealised treatment needs to be balanced against other considerations. The real benefits of the capital gains discount are small because those with high incomes tend to save almost the same amount irrespective of the tax rate on savings. The costs of the discount, however, are high. Other more distorting taxes must be higher. The discount encourages investors away from economic fundamentals towards investments with high capital gains. The discount undermines the integrity of the income tax system by creating opportunities for artificial transactions to reduce tax. And the discount reduces the progressivity of the tax system because high-income earners disproportionately earn capital gains.

A better balance between the competing considerations would reduce the discount so that \highlight{\Sexpr{latex_percent(1 - new.discount)} of capital gains are taxed}, which would raise around \highlight{\Sexpr{texNum(cost_of(policy_reduce_CGT), dollar = TRUE)}} a year.

Negative gearing in Australia goes beyond generally accepted principles for offsetting losses against gains. It distorts investment decisions, diverting capital from more productive investments, increasing volatility in housing markets, and increasing housing churn. It reduces home ownership and reduces the availability of long-term rentals, but does not materially increase housing supply. It is regressive, benefiting those on high incomes much more than those on low incomes. And it substantially reduces tax collections, imposing pressures on the budget so that either other taxes, or deficits, are higher.

Consequently, losses from all types of passive investments should not be deductible from wage and salary income. Suggested carve outs to exempt new property, or allow deductions up to a limit or for a limited number of properties, would have worse economic outcomes. In addition to the capital gains tax changes, restricting negative gearing would raise another \highlight{\Sexpr{texNum(cost_of(policy_year0) - cost_of(policy_reduce_CGT), dollar = TRUE)}} a year in the short term, declining to \highlight{\Sexpr{texNum(cost_of(policy) - cost_of(policy_reduce_CGT), dollar = TRUE)}} as losses accumulate.

These changes will improve housing affordability -- a little. We estimate housing prices would be up to 2 per cent lower than otherwise. Because there are tight planning constraints on new supply for urban housing, there will be very little impact on rents, or the rate of new development, even in the long term. 

Phasing in these changes would minimise price shocks and make reforms more politically palatable. Alternatively, current arrangements could be grandfathered. For capital gains tax, this would increase complexity and would be unfair to new investors -- particularly younger investors. For negative gearing it may be a reasonable compromise as properties tend to become positively geared over time anyway. 
\end{overview*}
\addtolength{\columnsep}{-\overviewextra}
 
%%%
\setcounter{tocdepth}{4}
\contentspage
%%%
\chapter{Commonwealth budgets under pressure}
In five of the last six years, the Commonwealth Government has posted headline deficits of more than 2~per cent of GDP.
Assuming revenue and spending projections are correct, Australia is on track for more than a decade of deficits between 2008 and 2019, with Commonwealth net debt projected to peak at 18~per cent of GDP in 2017, higher than any year since the mid-1990s.\footnote{Net debt was 18.1\%\ of GDP in 1995-96. See \textcite[p.~273]{Treasury2014b}}
 
As Grattan Institute's \emph{Fiscal Challenges for Australia} report highlights, reaching surplus in the next five years depends on higher income tax collections through bracket creep and optimistic assumptions about economic growth, the terms of trade and spending restraint.\footcite{DaleyWood2015}
 
The biggest worry is that budget projections assume that growth will return to ``trend''. The International Monetary Fund recently joined a growing group of economists who believe that long-run economic growth in developed countries was trending lower even before the financial crisis, and future expectations should be lower again.
 
 
The government's fiscal strategy relies heavily on these optimistic projections. The measures introduced in this year's budget will make no net improvement to the budget position in 2018-19. The government justifies its inaction by saying that the projections suggest it is on a ``clear and credible path back to surplus.''\footcite{Hockey2015} But projections over the past five years have consistently overestimated the position of the budget four years out.
 
However, hoping for the best is not a budget management strategy: it simply justifies putting off hard decisions, and shifts the costs and risks of budget repair onto future generations.
 
Grattan research shows that each \$40 billion dollar deficit increases the lifetime tax burden for households headed by a person aged 25 to 34 by \$10,000.
 
To bring their budgets back to balance, governments will need to undertake reforms on both the revenue and the spending side. But recently the Commonwealth Government's energy has been focussed on cuts to spending.
It has deferred any significant changes in its revenue mix until after its \emph{Tax White Paper}.
 
But there are revenue measures that could make a meaningful contribution to budget repair with little collateral damage. In recent and forthcoming papers, we articulate four policy proposals -- reducing superannuation tax concessions, changes to capital gains tax and negative gearing, broadening the GST and the introduction of a broad-based property levy -- that we think governments should adopt to improve their fiscal position.

<<CGT-CHAPTER, child='The-capital-gains-discount.Rnw'>>=
@

<<NGCHAPTER, child='Negative-gearing-chapter.Rnw'>>=
@

<<Impacts, child='Impact-of-changing-negative-gearing.Rnw'>>=
@

<<OPTIONS-FOR-REFORM, child='Options-for-reform-cgt.Rnw'>>=
@

<<sessionInfo, results = 'hide'>>=
devtools::session_info()
@

<<FINISH-TIME>>=
FINISH.TIME <- Sys.time()
write(x = c(as.POSIXct(START.TIME), as.POSIXct(FINISH.TIME), format(.POSIXct(difftime(FINISH.TIME, START.TIME, units = "secs"), tz = "GMT"), "%H:%M:%S")), 
      file = "CGT_and_neg_gearing_parent_time.txt")
@

\printbibliography[title=References]

\appendix
\chapter{Markov diagram for negative quarantining}
\begin{figure*}
\centering
\begin{tikzpicture}[-latex, auto, node distance = 2.8cm, on grid, semithick, state/.style = {draw, rounded corners, minimum height = 24pt}, every loop/.style={-latex}]
\node[state] (A) {$0$};
\node[state, right of=A] (B) {$1$};
\node[right of=B] (C) {\dots};
\node[above right of=B] (C1) {};
\node[state, right of=C] (D) {$n-1$};
\node[above left of =D] (C2) {};
\node[state, right of=D] (E) {$n$};
\node[state, right of=E] (F) {$n+1$};
\node[above right of=F] (G1) {};
\node[right of=F] (G) {\dots};
\node[state, right of=G] (H) {$h$};
\node[above left of =H] (G2) {};

\path (A) edge[out = 45, in = 135] node[anchor = south]{$1$} (B);
\path (B) edge[out = -135, in = -45] node[anchor = north]{$p$} (A);

\path (B) edge[out = 90, in = 180] node[anchor = south east]{$1 - p$} (C1);
\path (C2) edge[out = 0, in = 90] node[anchor = south west]{$1 - p$} (D);

\path (D) edge[out = 45, in = 135] node[anchor = south]{$1 - p$} (E);
\path (E) edge[out = 45, in = 135] node[anchor = south]{$1 - p$} (F);
\path (D) edge[out = -145, in = -55] node[anchor = south]{$p$} (A);
\path (E) edge[out = -145, in = -65] node[anchor = south]{$p$} (A);
\path (F) edge[out = -145, in = -75] node[anchor = south]{$p$} (A);

\path (F) edge[out = 90, in = 180] node[anchor = south east]{$1 - p$} (G1);
\path (G2) edge[out = 0, in = 90] node[anchor = south west]{$1 - p$} (H);

\path (H) edge[out = -145, in = -85] node[anchor = south]{$p$} (A);
\path (H) edge [loop right, draw, -latex] node[anchor = west]{$1 - p$} (A);
\end{tikzpicture}
\end{figure*}
\begin{figure*}
\Caption{Positive gearing absorbing ($M4$)}{Diagram of model. $q = {}$ probability of negatively gearing if a property investor}{fig:Markov-M4}
\begin{tikzpicture}[-latex, auto, node distance = 2.8cm, on grid, semithick, state/.style = {draw, rounded corners, minimum height = 24pt}, every loop/.style={-latex}]
\node[state] (1) {$\ell = 1$};
\node[left of = 1, align = right] (0) {Negative gearing};
\node[state, below of = 1] (2) {$\ell = 1$};
\node[left of = 2, align = right] (0A) {Positive gearing};
\node[state, right of = 1] (3) {$\ell = 2$};
\node[right of = 3] (dot1) {\dots};
\node[state, below of = 3] (4) {$\ell = 2$};

\path (1) edge node[anchor = south]{$q$} (3);
\path (1) edge node[anchor = west]{$1 - q$}(2);
\path (3) edge node[anchor = south]{$q$} (dot1);
\path (3) edge node[anchor = west]{$1 - q$}(4);

\path (2) edge[loop below] node[anchor=north]{$1$} (2L);
\path (4) edge[loop below] node[anchor=north]{$1$} (4L);
\end{tikzpicture}
\end{figure*}

\begin{figure*}
\Caption{Positive gearing absorbing, age-based ($MA$)}{Diagram of model. $q_x = {}$ probability of negatively gearing, given a property investor at age $x$}{fig:Markov-MA}
\begin{tikzpicture}[-latex, auto, node distance = 2.8cm, on grid, semithick, state/.style = {draw, rounded corners, minimum height = 30pt}, every loop/.style={-latex}]
\node[state] (1) {$\ell = 1$};
\node[left of = 1, align = right] (0) {Negative gearing};
\node[state, below of = 1] (2) {$\ell = 1$};
\node[left of = 2, align = right] (0A) {Positive gearing};
\node[state, right of = 1] (3) {$\ell = 2$};
\node[right of = 3] (dot1) {\dots};
\node[state, below of = 3] (4) {$\ell = 2$};

\path (1) edge node[anchor = south]{$q_a$} (3);
\path (1) edge node[anchor = west]{$1 - q_a$}(2);
\path (3) edge node[anchor = south]{$q_{a + 1}$} (dot1);
\path (3) edge node[anchor = west]{$1 - q_{a + 1}$}(4);

\path (2) edge[loop below] node[anchor=north]{$1$} (2L);
\path (4) edge[loop below] node[anchor=north]{$1$} (4L);

\node[state, right of = dot1] (6) {$\ell = 6$};
\node[state, below of = 6] (7) {$\ell = 6$}; 
\node[right of = 6] (dot2) {\dots};
\node[state, right of = dot2] (11) {$\ell = m + 1$};
\node[state, below of = 11] (12) {$\ell = m + 1$};
\node[right of = 11] (dot3) {\dots};

\path (dot1) edge node[anchor = south]{$q_{a + 4}$} (6);

\path (6) edge node[anchor = south]{$q_{a + 5}$} (dot2);
\path (6) edge node[anchor = west]{$1 - q_{a + 5}$}(7);

\path (7) edge[loop below] node[anchor=north]{$1$} (7L);

\path (dot2) edge node[anchor = south]{$q_{a + m - 1}$} (11);
\path (11) edge node[anchor = south]{$q_{a + m}$} (dot3);
\path (11) edge node[anchor = west]{$1 - q_{a + m}$} (12);

\path (12) edge[loop below] node[anchor=north]{$1$} (12L);
\end{tikzpicture}

\notes{$q_i = q_j$ for all $i,j \in \{a, a + 1, \dots, a + 4\}$ when $a = 0\mod 5$.}
\end{figure*}

\end{document}

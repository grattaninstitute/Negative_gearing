% !TeX program = pdflatex
\documentclass{grattan}

\title{Negative gearing and the capital gains discount}
\author{John Daley and Danielle Wood}

\addbibresource{bibliography.bib}
\addbibresource{bibliography2.bib} % r packages

\input{CGT-NG-sections/preamble}
<<MODELLING-PARAMETERS, echo=FALSE>>=
new.discount <- 0.25  # proposed CGT
TARGET.FY <- "2015-16"
use.sample.fy <- "2013-14"  # deprecated
latest.sample.fy <- "2013-14"
@


\begin{document}
%\clearpage
%\chapter{Distribution of negative gearing}
<<knitrOpts, echo=FALSE, results='hide'>>=
library(knitr)
.finished <- FALSE
file.create("CGT_and_neg_gearing_parent-CHUNKTIMINGS.txt")
knit_hooks$set(timeit = function(before) {
    if (before) {
      .current.time <<- Sys.time()
    } else {
      .duration <- formatC(round(difftime(Sys.time(), .current.time, units = "secs"), 1), 
                           # ensure one decimal place, right-aligned (width = 5)
                           format = "f", flag = "#", digits = 1, width = 5)
      if(!.finished)
        write(
          paste0(.duration, 
                 "\t", 
                 knitr::opts_current$get(name = "label")),
          file = "CGT_and_neg_gearing_parent-CHUNKTIMINGS.txt",
          ncolumns = 1,
          append = TRUE)
    }
})


library(devEMF)
START.TIME <- Sys.time()
my_pdf <- function(file, width, height){
  pdf(file = file, width, height = height)
}

my_emf <- function(file, width, height){
  emf(file = file, width = width, height = height)
}

# knitr chunk opts
# fig.width must = out.width and same for *.height
knitr::opts_chunk$set(fig.width=11.000, 
                      fig.height=7.00, 
                      out.width="11.000in", 
                      out.height="7.00in", 
                      fig.show='hide',
                      echo=FALSE,
                      fig.path= atlas <- "CGT-NG-atlas/",
                      message=FALSE, 
                      warning=FALSE, 
                      timeit =TRUE
                      #
                      ,error=FALSE
                      ,results='hide'
                      ,cache=FALSE
                      ,dev=c('my_pdf', 'my_emf', 'png')
                      ,fig.ext = c("pdf", 'emf', "png")
)
@

<<loadPackages, echo=FALSE, dev='pdf', echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE>>=
library(knitr)
library(data.table)
library(dplyr)
library(car)
library(devEMF)
library(gridExtra)
library(ggplot2)
library(scales)
library(directlabels)
library(grattan)
library(xtable)
library(readxl)
library(openxlsx)
library(readr)
library(rsdmx)
library(httr)
library(zoo)
library(survey)
library(foreign)
library(Hmisc)
library(expm)
library(devtools)
library(tidyr)
library(magrittr)
library(taxstats)
@

<<downloadGrattex>>=
overwrite_grattex <- FALSE && (!file.exists("grattan.cls") || (difftime(Sys.time(), file.info("grattan.cls")$ctime, units = "days") > 2))
if (overwrite_grattex){
  GET(url = "https://raw.githubusercontent.com/HughParsonage/grattex/master/grattan.cls", 
      write_disk("grattan.cls", overwrite = TRUE))
}
@

<<packcageCitation>>=
# Select packages to cite:
citPkgs <- names(sessionInfo()$otherPkgs)
# Write the bibtex file:
knitr::write_bib(citPkgs, file="bibliography2.bib")      
package_cite_input <- paste0("\\nocite{", paste0(paste0("R-", citPkgs), collapse=","), "}")
write(package_cite_input, file = "package_cite_input.tex")
@
% citations
%\input{package_cite_input}

% \textheight quite small for flushbottom
\raggedbottom

<<latex_percent>>=
latex_percent <- function (x, percentage_symbol = "~percent") {
    x <- plyr::round_any(x, scales:::precision(x)/100)
    stringr::str_c(comma(x * 100), percentage_symbol)
}
@

<<select_which_>>=
select_which_ <- function(.data, Which, .and.dots) {
  Which <- match.fun(Which)
  if (!missing(.and.dots)) {
    select_(.data, .dots = c(names(.data)[sapply(.data, Which)], .and.dots))
  } else {
    select_(.data, .dots = names(.data)[sapply(.data, Which)])
  }
}
@



<<xtable-formatting>>=
# bold column names
boldxt <- function(x, sanitize = TRUE) {
  # Replace $ without \\
  x <- ifelse(grepl("((?<!\\\\)\\$)", x, perl = TRUE), gsub("$", "\\$", x, fixed = TRUE), x)
  paste('{\\textbf{',x,'}}', sep ='')
}
options("xtable.sanitize.colnames.function" = function(x) boldxt(x))
@

<<load_sample_file>>=
sample_file <- sample_files_all[fy.year == use.sample.fy]
@

<<create-age-imp>>=
sample_file <- merge(sample_file, age_range_decoder, by = "age_range")

set.seed(48031)
sample_file %<>%
  group_by(age_range_description) %>%
  mutate(min_age = ifelse(grepl("to", age_range_description), 
                          as.numeric(stringr::str_extract(age_range_description, "^[0-9]{2}")), 
                          ifelse(grepl("70", age_range_description),
                                 70, 
                                 15)),
         max_age = min_age + 5, 
         age_imp = runif(n(), min_age, max_age)) 
@

<<target_sample_file>>=
keep.names <- names(sample_file)
target_sample_file <- 
  sample_file %>%
  project_to(to_fy = TARGET.FY, fy.year.of.sample.file = latest.sample.fy) %>%
  select_(.dots = keep.names)
rm(keep.names)
@


%%% Costings analysis

<<Determine_future_rental_deductions>>=
historical.interest.losses <- 
  sample_files_all %>%
  group_by(year = fy2yr(fy.year)) %>%
  summarise(tot.rent_interest_deds = sum(as.numeric(Rent_int_ded_amt * WEIGHT)))

total.investor.loans <- 
  read_excel("ABS_Household_financing.xlsx", sheet = "Investment_loans_outstanding") %>%
  group_by(year = lubridate::year(Date)) %>%
  summarise(loans_amt = mean(Investment_housing_all_deposit_taking_institutions) * 10^6)

rba_interest <- 
  read_excel("RBA_Household_interest_rates.xlsx", sheet = "Housing_lending_rates") %>%
  group_by(year = lubridate::year(Date)) %>%
  summarise(mean.i = mean(Housing_lending_rate)/100)

interest_losses <-
  merge(total.investor.loans, rba_interest) %>%
  merge(., historical.interest.losses, all.x = TRUE) %>%
  mutate(interestXloans = mean.i * loans_amt)

# Good enough 
# plot(lm(tot.rent_interest_deds ~ interestXloans, data = interest_losses))
rental.losses <-
interest_losses[!complete.cases(interest_losses), ] %>%
  do({
    model <- lm(tot.rent_interest_deds ~ interestXloans, data = interest_losses)
    pred <- predict(model, newdata = .[c("interestXloans")])
    data.frame(., pred)
  }) %>%
  mutate(tot.rent_interest_deds = pred) %>%
  select(year, tot.rent_interest_deds) %>%
  rbind(select(interest_losses, year, tot.rent_interest_deds)) %>%
  filter(!is.na(tot.rent_interest_deds)) %>%
  arrange(year) %>% 
  mutate(ratio = tot.rent_interest_deds/tot.rent_interest_deds[which(year == 2013)])

# It's about 1 for 2015, (certainly if se is taken into acct), so I'm not going to bother

@



<<cost-new-CGT-discount>>=
revenue_CGT_discount <- function(CGT.discount = new.discount, fy.year = TARGET.FY, eventual = 20, .old.discount = 0.50){
  stopifnot(is.fy(fy.year))
  if (fy.year >= "2012-13"){
    sample_file <-
      sample_file_1213 %>%
      project_to(fy.year) 
  } else {
    stopifnot(fy.year < "2003-04")
    sample_file <- sample_files_all[fy.year == TARGET.FY]
  }
  
  # We assume that 100% of individuals enjoyed the CGT discount
  revenue_CGT_discount_sample_file <- 
    sample_file %>%
    mutate(new_Net_CG_amt = (Net_CG_amt / (1 - .old.discount)) * (1 - CGT.discount),
           new_Tot_inc_amt = Tot_inc_amt - Net_CG_amt + new_Net_CG_amt,
           new_Tot_ded_amt = Tot_ded_amt,  # no change
           new_Taxable_Income = new_Tot_inc_amt - new_Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed,
           old_tax = income_tax(Taxable_Income, fy.year = fy.year),
           new_tax = income_tax(new_Taxable_Income, fy.year = fy.year),
           taxdiff = new_tax - old_tax)
  
  revenue_CGT_discount_sample_file %$%
    sum(taxdiff * WEIGHT)
}
@

<<revenue_abolish_NG>>=
revenue_abolish_NG <- function(fy.year = "2016-17"){
  sample_file_1314 %>%
    select(-contains("MCS")) %>%  # project not good
    project_to(fy.year, fy.year.of.sample.file = use.sample.fy) %>%
    mutate(new_Tot_inc_amt = Tot_inc_amt - Net_rent_amt + pmaxC(Net_rent_amt, 0),
           new_Taxable_Income = new_Tot_inc_amt - Tot_ded_amt - NPP_loss_claimed - PP_loss_claimed, 
           prev_tax = income_tax(Taxable_Income, fy.year = "2015-16"), 
           new_tax  = income_tax(new_Taxable_Income, fy.year = "2015-16")) %$%
    sum((new_tax - prev_tax) * WEIGHT)
}

@

<<cgt_discount_density>>=
cgt_discount_distribution <- 
  sample_file %>%
  filter(Tot_CY_CG_amt > 0) %>%
  group_by(apparent_discount = round((1 - Net_CG_amt / Tot_CY_CG_amt) * 4) / 4) %>%
  summarise(value = sum(Tot_CY_CG_amt)) %>%
  ungroup %>%
  mutate(density = value / sum(value)) %>%
  arrange(apparent_discount) %>% 
  mutate(cumdensity = cumsum(density))

probNoDiscount <- 
  cgt_discount_distribution %>% 
  filter(apparent_discount == 0) %$%
  cumdensity
@

<<revenue_quarantine_NG_year0>>=
# new.discount <- 0.25  # proposed CGT
# TARGET.FY <- "2015-16"
# use.sample.fy <- "2013-14"
revenue_quarantine_NG_year0 <- function(sample_file = sample_file_1314, new_CGT_discount = new.discount, sample_file_fy_year = use.sample.fy){
  
  if (sample_file_fy_year != "2013-14"){
    stop("Correct sample_file year")
  } 
  
  round_cols <- function(column){
    if (!is.numeric(column)){
      column
    } else {
      round(column, 2)
    }
  }
  target_sample_file %>%
    mutate_each(funs(round_cols)) %>%
    
    # We need to work out how much the discount will change Net_CG_amt.
    # We use the density of the apparent_discount to randomly 
    # assign a new discount rate.  Note that this does not 
    # adequately take into account the impact of capital losses
    mutate(
      new_Net_CG_amt = ifelse(runif(n()) < probNoDiscount, 
                              Net_CG_amt, 
                              (Net_CG_amt / (1 - .old.discount)) * (1 - CGT.discount))) %>%
    
    # Excluding CG for the moment, we create a new total income amount 
    # which quarantines salary.
    mutate(
      # Other_Income means income (possibly -ve) that is 
      # not salary, CG, or rental
      Other_Income = round(Tot_inc_amt - Sw_amt - Net_CG_amt - Net_rent_amt, 2),
      new_Tot_inc_amt_no_CG = Sw_amt + ifelse(Net_rent_amt >= 0, 
                                              Other_Income + Net_rent_amt, 
                                              ifelse(Other_Income + Net_rent_amt >= 0, 
                                                     Other_Income + Net_rent_amt, 
                                                     Other_Income))
    ) %>% 
    mutate(
      # This is the standard calculation for taxable income
      new_Taxable_Income = pmaxC(new_Tot_inc_amt_no_CG + Net_CG_amt - Tot_ded_amt - NPP_loss_claimed - PP_loss_claimed, 0),
      prev_tax = grattan:::.income_tax(Taxable_Income, fy.year = "2013-14"), 
      post_tax = grattan:::.income_tax(new_Taxable_Income, fy.year = "2013-14"), 
      tax_increase = post_tax - prev_tax
    ) %$% 
      # as.numeric for integer overflow
    sum(as.numeric(tax_increase * WEIGHT))
}
@

<<revenue_quarantine_NG, eval=F>>=
# new.discount <- 0.25  # proposed CGT
# TARGET.FY <- "2015-16"
# use.sample.fy <- "2013-14"
revenue_quarantine_NG <- function(h = 10L, sample_file = sample_file_1314, new_CGT_discount = new.discount, sample_file_fy_year = use.sample.fy, target_fy = TARGET.FY, Z = 10){
  # Z is the extent of the model
  # h is the number of years the 
  
  if (sample_file_fy_year != "2013-14"){
    stop("You must correct the sample_file year")
  }
  
  probCG_if_investor <- 
    sample_file_1314 %>%
    filter(Gross_rent_amt > 0) %$%
    mean(Net_CG_amt > 0)
  
  probCG <- probCG_if_investor
  
  M <- matrix(0, ncol = Z + 1, nrow = Z + 1)
  # We assume that an individual with Gross rent accumulates their losses
  # linearly and that all losses are exhausted completely with probability
  # probCG.  Put another way, at each iteration we randomly allocate property 
  # investors into either realizing a capital gain or not.  If they realize, 
  # all accumulated losses (regardless of size) is deducted from their taxable 
  # income; otherwise it increases arithmetically.
  M[row(M) == col(M) - 1] <- 1 - probCG
  M[col(M) == 1] <- probCG
  
  # This isn't quite enough: too high a chance of large 
  # accumulated losses
  
  # Losses not permitted to be exhausted in year 1. (Since they have been accounted for.)
  M[1,2] <- 1
  M[1,1] <- 0
  #
  # (Z+1) represents the node of having no ability to write off-losses, even 
  # after Z years.
  M[Z + 1, 1] <- 0
  M[Z + 1, Z + 1] <- 1
  
  # An alternative route with (0) as an absorbing state
  X <- matrix(0, ncol = Z + 1, nrow = Z + 1)
  X[col(M) == 1] <- probCG
  X[row(X) == col(X) - 1] <- 1 - probCG
  X[1,1] <- 1
  X[1,2] <- 0
  X[Z+1,1] <- 1
  
  # One more alternative, use probability of NG to determine whether to exit
  probNG <- mean(sample_file$Net_rent_amt < 0)
  
  # 1: no accumulated losses
  # 2: initial state
  # n: n-1 times accumulated losses
  M2 <- matrix(0, ncol = Z + 1, nrow = Z + 1)
  M2[row(M2) == col(M2) - 1] <- 1 - probCG
  M2[col(M2) == 1] <- probCG
  
  # Initial state guaranteed to move to (3)
  M2[row(M2) == 2] <- 0
  M2[2,3] <- 1
  
  # Exit from (1) governed by probNG
  M2[row(M2) == 1] <- 0
  M2[1,2] <- probNG
  M2[1,1] <- 1 - probNG
  
  # Last state: Guaranteed to exhaust.
  M2[row(M2) == Z + 1] <- 0
  M2[Z + 1, 1] <- 1
  
  stopifnot(all(rowSums(M2) == 1))
  
  stopifnot(all(rowSums(X) == 1))

  # require(expm)
  P <- M2 %^% (Z + 1)
  
  probNG_if_investor <- 
    sample_file %>%
    filter(Gross_rent_amt > 0) %$%
    mean(Net_rent_amt < 0)
  M3 <- matrix(0, nrow = Z + 1, ncol = Z + 1)
  #
  # 1: None
  # 2: 1 accumulated loss (initial)
  # n: n - 1 accumulated loss
  M3[row(M3) == col(M3) - 1] <- (1 - probCG) * probNG_if_investor
  M3[row(M3) == col(M3)] <- 1 - (1 - probCG) * probNG_if_investor
  M3[Z + 1, Z + 1] <- 1
  
  # Next steps? Use age to better estimate p and q
  stopifnot(all(rowSums(M3) == 1))
  
  # +ve gearing absorbing
  M4 <- matrix(0, nrow = 2*Z, ncol = 2*Z)
  M4[row(M4) == col(M4) - 2] <- probNG_if_investor
  M4[row(M4) == col(M4) - 1] <- 1 - probNG_if_investor
  M4[row(M4) %% 2 == 0] <- 0
  M4[row(M4) %% 2 == 0 & row(M4) == col(M4)] <- 1
  M4[2*Z - 1, 2*Z] <- 1
  
  stopifnot(all(rowSums(M4) == 1))
  
  P <- M4 %^% (Z + 1)
  
  init <- c(1,rep(0, Z - 1))
  
  # even entries of P are the absorbing states
  E <- init %*% P[c(TRUE, FALSE),c(FALSE,TRUE)]
  
  accumulator <- 
    data.table(rand = cumsum(E[1,]), 
               loss_multiplier = 1:(Z)) %>%
    setkey(rand)
  
  round_cols <- function(column){
    if (!is.numeric(column)){
      column
    } else {
      round(column, 2)
    }
  }
  target_sample_file %>%
    mutate_each(funs(round_cols)) %>%
    
    # We need to work out how much the discount will change Net_CG_amt.
    # We use the density of the apparent_discount to randomly 
    # assign a new discount rate.  Note that this does not 
    # adequately take into account the impact of capital losses
    mutate(
      new_Net_CG_amt = Net_CG_amt * ifelse(runif(n()) < probNoDiscount, 
                                           1, 
                                           (1 - new_CGT_discount) / 0.50)) %>%
    
    # Excluding CG for the moment, we create a new total income amount 
    # which quarantines salary from NG.  Rental losses may be deducted 
    # against investment income (including capital gains).  However, 
    # we assume that they are deducted against capital gains only
    # in the future
    mutate(
      # Other_Income means income (possibly -ve) that is 
      # not salary, CG, or rental
      quarantined_income = Sw_amt + Alow_ben_amt + ETP_txbl_amt,
      Other_Income = round(Tot_inc_amt - quarantined_income - Net_CG_amt - Net_rent_amt, 2),
      new_Tot_inc_amt_no_CG = quarantined_income + ifelse(Other_Income <= 0, 
                                                          # Nothing for rent to deduct against, 
                                                          # but Other_Income is permitted to be -ve
                                                          Other_Income,
                                                          # Net_rent is negative and is allowed to 
                                                          # reduce Other income till exhausted
                                                          pmaxC(Other_Income + Net_rent_amt, 0))
    ) %>% 
    mutate(
      # should be positive
      accumulated_losses_year_0 = -1 * ifelse(Net_rent_amt >= 0, 
                                              0, 
                                              pminC(Other_Income + Net_rent_amt, 0)), 
      new_Tot_inc_amt = new_Tot_inc_amt_no_CG + Net_CG_amt
    ) %>% 
    mutate(rand = runif(n())) %>%
    setkey(rand) %>%
    accumulator[., roll = -Inf] %>%
    mutate(
      accumulated_losses_year_Z = accumulated_losses_year_0 * loss_multiplier
    ) %>% 
    mutate(
      # This is the standard calculation for taxable income
      new_Taxable_Income = pmaxC(pmaxC(Other_Income + new_Net_CG_amt - accumulated_losses_year_Z, 
                                       0) + quarantined_income - Tot_ded_amt - NPP_loss_claimed - PP_loss_claimed, 
                                 0),
      prev_tax = grattan:::.income_tax(Taxable_Income, fy.year = "2013-14"), 
      post_tax = grattan:::.income_tax(new_Taxable_Income, fy.year = "2013-14"), 
      tax_increase = post_tax - prev_tax
    )
}
@

<<Summary-chunk, results='hide', eval = TRUE>>=
weighting <- function(year) lf_inflator_fy(to_fy = yr2fy(year))

# Our proposal
policy <- revenue_quarantine_NG(h = NULL, 
                                sample_file = sample_file_1314, 
                                new_CGT_discount = 0.25, 
                                sample_file_fy_year = "2013-14", 
                                target_fy = TARGET.FY, 
                                Z = 50)
# The Henry proposal
policy_align_gains_and_losses <- 
  henry_taxstats(2015, new.discount = new.discount)

just_negative_gearing_taxstats_year0 %>%
  mutate(diff = new_tax - current_tax) %$%
  round(sum(diff) * weighting(2015) / 1e9, 1) ->
  
  diff_just_due_NG_year0


just_negative_gearing_taxstats %$%
  round(sum(diff) * weighting(2015) / 1e9, 1) ->
  
  diff_just_due_NG


policy %$%
  round(sum(diff)*weighting(2015)/1e9, 1) ->
  cost_of_policy_2015

costing_policy_2015_year0 <-
  cost_of_daley_policy_fast(2015, eventual = 0) %$%
  round(sum(diff) * weighting(2015) / 1e9, 1) 

cost_align_gains_and_losses <- 
  policy_align_gains_and_losses %$%
  round(sum(diff)*weighting(2015)/1e9, 1)

cost_align_gains_and_losses_NG <-
  policy_align_gains_and_losses %>%
  mutate(
    new_Taxable_Income = Taxable_Income - Net_rent_amt + new_net_rent - Net_fincl_invstmt_lss_amt + new_invstment_lss,
    new_tax_only_NG = income_tax(new_Taxable_Income),
    diff_due_NG = new_tax_only_NG - current_tax
    ) %$%
  round(sum(diff_due_NG) * weighting(2015) / 1e9, 1)

write(x = c(
  paste("Cost of policy by policy option with CGT discount set at", percent(new.discount)),
  "===================================="),
  file = "Summary_table.txt")

write(x = c(
  costing_policy_2015_year0, "Quarantine NG losses and reduce CGT discount (Year 0)", 
  cost_of_policy_2015, "Quarantine NG losses and reduce CGT discount", 
  cost_of_red_CGT_discount, "Reduce CGT discount", 
  diff_just_due_NG, "Just quarantine losses", 
  diff_just_due_NG_year0, "Just quarantine losses (year 0)",
  cost_align_gains_and_losses, "Henry proposal", 
  cost_align_gains_and_losses_NG, "Henry proposal (just NG)"
      ),
  file = "Summary_table.txt",
  append = TRUE,
  ncolumns = 2
  )
@

<<CostofNGtotal>>=
sample_file_1213 %>%
  mutate(new_tax = income_tax(Taxable_Income - pmin(0, Net_rent_amt)),
         diff = new_tax - income_tax(Taxable_Income)) %$%
  sum(diff) * 50 / 1e9  ->
  NG.tx.exp

NG.tx.exp <- round(NG.tx.exp, 1)
@

\begin{overview}[-35pt]
\addtolength{\columnsep}{1pt}
Two decades of strong house price growth and falling rates of home ownership have raised questions about the appropriateness of generous tax concessions for property investment. As the Commonwealth Government looks for revenue measures to address its structural budget problems, it is unsurprising that winding back \highlight{negative gearing} and the \highlight{capital gains tax (CGT) discount} are high on the list of many commentators' options. 

Together negative gearing and the CGT discount allow investors to use debt financed investment (particularly property investment) to reduce and defer personal income tax. These tax concessions have reduced housing affordability. They increase investor activity by increasing post-tax returns to rental housing, pushing up prices to the disadvantage of young would-be home buyers. Like most tax concessions, these tax breaks largely benefit the wealthy. 

Changes to both capital gains tax and negative gearing are needed to address these efficiency and fairness issues. 
 
The current 50 per cent CGT discount is justified on the basis that it promotes savings and investment. But these benefits can be overstated: tax rates don't do much to affect the total amount that wealthy people save. And entrepreneurs already receive a range of other tax concessions. Some discount remains justified to avoid taxing investors for inflationary gains. But the discount is larger than it needs to be given its budgetary and economic costs. \highlight{Reducing the CGT discount to \Sexpr{latex_percent(new.discount)}} could raise around \Sexpr{texNum(revenue_CGT_discount(CGT.discount = new.discount, fy.year = TARGET.FY), sig.figs = 1L, dollar = TRUE)} annually.
 
Negative gearing should also be limited. There is no basis for the claims from the property industry that negative gearing serves a broader social purpose in moderating house prices and rents. Negative gearing puts upward pressure on house prices and plays little role in moderating rents. 

Quarantining losses so they can only be written off against other investment income (operating profits and capital gains) could raise around \$\TBD{3 billion} a year in the short-term. This would decline to around \$\TBD{2 billion} over time as those losses are offset against investment income. 

An alternative reform would align the tax deductions for capital losses with that for gains.  For example, if the capital gains tax discount is reduced to \Sexpr{latex_percent(new.discount)} (investors pay tax on \Sexpr{latex_percent(1 - new.discount)} of their capital gains), then investors could deduct \Sexpr{latex_percent(1 - new.discount)} of their investment losses. Treating capital gains and recurrent losses consistently would reduce tax incentives to borrow to invest. It would contribute around \$\TBD{3.7 billion} a year to the bottom line. 

Other proposals such as only allowing full deductibility of losses for new properties are somewhat less economically desirable but would still be a large improvement on current arrangements. 

The best way to transition to the new arrangements would be to phase them in over a number of years. Such a phase-in will help smooth reductions in asset prices and reduce resistance to reform. For capital gains tax changes, phasing the changes in for all investors would be preferable to grandfathering which introduces complexity and is unfair to new investors -- particularly younger investors. However, grandfathering tax concessions for properties that are already negatively geared may be a reasonable compromise because properties tend to become positively geared over time as rents increase and the loan principal is repaid. 
\end{overview}
 
%%%
\setcounter{tocdepth}{4}
\contentspage
%%%
\chapter{Commonwealth budgets under pressure}
In five of the last six years, the Commonwealth Government has posted headline deficits of more than 2~per cent of GDP.
Assuming revenue and spending projections are correct, Australia is on track for more than a decade of deficits between 2008 and 2019, with Commonwealth net debt projected to peak at 18~per cent of GDP in 2017, higher than any year since the mid-1990s.\footnote{Net debt was 18.1\%\ of GDP in 1995-96. See \textcite[p.~273]{Treasury2014b}}
 
As Grattan Institute's \emph{Fiscal Challenges for Australia} report highlights, reaching surplus in the next five years depends on higher income tax collections through bracket creep and optimistic assumptions about economic growth, the terms of trade and spending restraint.\footcite{DaleyWood2015}
 
The biggest worry is that budget projections assume that growth will return to ``trend''. The International Monetary Fund recently joined a growing group of economists who believe that long-run economic growth in developed countries was trending lower even before the financial crisis, and future expectations should be lower again.
 
 
The government's fiscal strategy relies heavily on these optimistic projections. The measures introduced in this year's budget will make no net improvement to the budget position in 2018-19. The government justifies its inaction by saying that the projections suggest it is on a ``clear and credible path back to surplus.''\footcite{Hockey2015} But projections over the past five years have consistently overestimated the position of the budget four years out.
 
However, hoping for the best is not a budget management strategy: it simply justifies putting off hard decisions, and shifts the costs and risks of budget repair onto future generations.
 
Grattan research shows that each \$40 billion dollar deficit increases the lifetime tax burden for households headed by a person aged 25 to 34 by \$10,000.
 
To bring their budgets back to balance, governments will need to undertake reforms on both the revenue and the spending side. But recently the Commonwealth Government's energy has been focussed on cuts to spending.
It has deferred any significant changes in its revenue mix until after its \emph{Tax White Paper}.
 
But there are revenue measures that could make a meaningful contribution to budget repair with little collateral damage. In recent and forthcoming papers, we articulate four policy proposals -- reducing superannuation tax concessions, changes to capital gains tax and negative gearing, broadening the GST and the introduction of a broad-based property levy -- that we think governments should adopt to improve their fiscal position.

<<CGT-CHAPTER, child='The-capital-gains-discount.Rnw'>>=
@

<<NGCHAPTER, child='Negative-gearing-chapter.Rnw'>>=
@

<<Impacts, child='Impact-of-changing-negative-gearing.Rnw'>>=
@

<<sessionInfo, results = 'hide'>>=
devtools::session_info()
@

<<FINISH-TIME>>=
FINISH.TIME <- Sys.time()
write(x = c(START.TIME, FINISH.TIME, difftime(FINISH.TIME, START.TIME)), file = "CGT_and_neg_gearing_parent_time.txt")
@

\printbibliography[title=References]

\appendix
\chapter{Markov diagram for negative quarantining}
\begin{figure*}
\centering
\begin{tikzpicture}[-latex, auto, node distance = 2.8cm, on grid, semithick, state/.style = {circle, draw, minimum width = 36pt}]
\node[state] (A) {$0$};
\node[state, right of=A] (B) {$1$};
\node[right of=B] (C) {\dots};
\node[above right of=B] (C1) {};
\node[state, right of=C] (D) {$n-1$};
\node[above left of =D] (C2) {};
\node[state, right of=D] (E) {$n$};
\node[state, right of=E] (F) {$n+1$};
\node[above right of=F] (G1) {};
\node[right of=F] (G) {\dots};
\node[state, right of=G] (H) {$h$};
\node[above left of =H] (G2) {};

\path (A) edge[out = 45, in = 135] node[anchor = south]{$1$} (B);
\path (B) edge[out = -135, in = -45] node[anchor = north]{$p$} (A);

\path (B) edge[out = 90, in = 180] node[anchor = south east]{$1 - p$} (C1);
\path (C2) edge[out = 0, in = 90] node[anchor = south west]{$1 - p$} (D);

\path (D) edge[out = 45, in = 135] node[anchor = south]{$1 - p$} (E);
\path (E) edge[out = 45, in = 135] node[anchor = south]{$1 - p$} (F);
\path (D) edge[out = -145, in = -55] node[anchor = south]{$p$} (A);
\path (E) edge[out = -145, in = -65] node[anchor = south]{$p$} (A);
\path (F) edge[out = -145, in = -75] node[anchor = south]{$p$} (A);

\path (F) edge[out = 90, in = 180] node[anchor = south east]{$1 - p$} (G1);
\path (G2) edge[out = 0, in = 90] node[anchor = south west]{$1 - p$} (H);

\path (H) edge[out = -145, in = -85] node[anchor = south]{$p$} (A);
\path (H) edge [loop right, draw, -latex] node[anchor = west]{$1 - p$} (A);
\end{tikzpicture}
\end{figure*}
\begin{figure*}
\caption{Positive gearing absorbing ($M4$)}
\begin{tikzpicture}[-latex, auto, node distance = 2.8cm, on grid, semithick, state/.style = {circle, draw, minimum width = 36pt}, every loop/.style={-latex}]
\node[state] (1) {$\ell = 1$};
\node[left of = 1, align = right] (0) {Negative gearing};
\node[state, below of = 1] (2) {$\ell = 1$};
\node[left of = 2, align = right] (0A) {Positive gearing};
\node[state, right of = 1] (3) {$\ell = 2$};
\node[right of = 3] (dot1) {\dots};
\node[state, below of = 3] (4) {$\ell = 2$};

\path (1) edge node[anchor = south]{$q$} (3);
\path (1) edge node[anchor = west]{$1 - q$}(2);
\path (3) edge node[anchor = south]{$q$} (dot1);
\path (3) edge node[anchor = west]{$1 - q$}(4);

\path (2) edge[loop below] node[anchor=north]{$1$} (2L);
\path (4) edge[loop below] node[anchor=north]{$1$} (4L);
\end{tikzpicture}
\end{figure*}
\end{document}

HHW.quintiles.eq = factor(HHW.quintiles.eq)) %>%
ggplot(aes(x = HHDI.quintiles.eq, y = HHW.quintiles.eq)) +
geom_tile(aes(fill = HSL.total.discrete), linetype = 2) +
#geom_point(aes(colour = HSL.total.discrete)) +
theme_hugh() + scale_fill_manual(values = gpal(6)) +
scale_color_manual(values = rev(gpal(6))) +
#   geom_tile(aes(alpha = HSL.total.discrete),
#             fill = "black", colour = "white") +
theme_hugh() +
theme(panel.grid.major = element_blank()) + scale_x_discrete(expand = c(0,0)) +
# scale_alpha_manual(values = (1/8)*(0:8)) +
scale_y_discrete(expand = c(0,0)) +
xlab("Income quintile") +
guides(fill = guide_legend("Health services levy,\ntotal impact", title.theme = element_text(size = 22, angle = 0, lineheight = 0.75))) +
theme(legend.position = "right",
axis.title.x = element_text(hjust = 0.5)) +
annotate("text", x = 1, y = 5, label = "Cash poor, asset rich")
# ====
dat2 %>%
mutate(HSL.total.discrete = cut(HSL.total, breaks = 0.25*c(0:6), labels = c(paste0("< $", round(0.25*(1:6), 2)))),
HHDI.quintiles.eq = factor(HHDI.quintiles.eq),
HHW.quintiles.eq = factor(HHW.quintiles.eq)) %>%
ggplot(aes(x = HHDI.quintiles.eq, y = HHW.quintiles.eq)) +
geom_tile(aes(fill = HSL.total.discrete), linetype = 2) +
#geom_point(aes(colour = HSL.total.discrete)) +
theme_hugh() + scale_fill_manual(values = rev(gpal(6))) +
scale_color_manual(values = rev(gpal(6))) +
#   geom_tile(aes(alpha = HSL.total.discrete),
#             fill = "black", colour = "white") +
theme_hugh() +
theme(panel.grid.major = element_blank()) + scale_x_discrete(expand = c(0,0)) +
# scale_alpha_manual(values = (1/8)*(0:8)) +
scale_y_discrete(expand = c(0,0)) +
xlab("Income quintile") +
guides(fill = guide_legend("Health services levy,\ntotal impact", title.theme = element_text(size = 22, angle = 0, lineheight = 0.75))) +
theme(legend.position = "right",
axis.title.x = element_text(hjust = 0.5)) +
annotate("text", x = 1, y = 5, label = "Cash poor, asset rich")
# ====
dat2 %>%
mutate(HSL.total.discrete = cut(HSL.total, breaks = 0.25*c(0:6), labels = c(paste0("< $", round(0.25*(1:6), 2)))),
HHDI.quintiles.eq = factor(HHDI.quintiles.eq),
HHW.quintiles.eq = factor(HHW.quintiles.eq)) %>%
ggplot(aes(x = HHDI.quintiles.eq, y = HHW.quintiles.eq)) +
geom_tile(aes(fill = HSL.total.discrete), linetype = 2) +
#geom_point(aes(colour = HSL.total.discrete)) +
theme_hugh() + scale_fill_manual(values = rev(gpal(6))[c(1,2,6)]) +
scale_color_manual(values = rev(gpal(6))) +
#   geom_tile(aes(alpha = HSL.total.discrete),
#             fill = "black", colour = "white") +
theme_hugh() +
theme(panel.grid.major = element_blank()) + scale_x_discrete(expand = c(0,0)) +
# scale_alpha_manual(values = (1/8)*(0:8)) +
scale_y_discrete(expand = c(0,0)) +
xlab("Income quintile") +
guides(fill = guide_legend("Health services levy,\ntotal impact", title.theme = element_text(size = 22, angle = 0, lineheight = 0.75))) +
theme(legend.position = "right",
axis.title.x = element_text(hjust = 0.5)) +
annotate("text", x = 1, y = 5, label = "Cash poor, asset rich")
source('C:/Users/hparsonage/Dropbox/Budget Repair Report/Data and analysis/Land tax/R/HSL modelling/HSLanalysis.R', echo=TRUE)
getwd()
setwd("C:/Users/hparsonage")
readLines("AP-Bibtex.txt")
readLines("AP-Bibtex.txt", n = 10)
readLines("AP-Bibtex.txt", n = 10)
raw <- readLines("AP-Bibtex.txt")
startlines <- grepl("@", raw, fixed=TRUE)
startlines
startlines <- grep("@", raw, fixed=TRUE)
startlines
ls()
rm(list = ls())
gc(1,1)
raw <- readLines("AP-Bibtex.txt")
startlines <- grep("@", raw, fixed=TRUE)
endlines <- grep("^}$", raw)
diff(startlines, endlines)
diff(endlines, startlines)
length(startlines)
length(endlines)
raw[endlines]
raw[startlines]
grepl("^}$", "la}"})
grepl("^}$", "la}")
grepl("^}$", c("la}", "}")
grepl("^}$", c("la}", "}"))
"   url = {http://www.abs.gov.au/AUSSTATS/abs@.nsf/allprimarymainfeatures/98D6D587AFDEE8B1CA2578700014166B?opendocument}," -> text
grepl("^}$", text)
startlines <- grep("@[a-z]+{$", raw, fixed=TRUE)
startlines <- grep("@[a-z]+{\\s*$", raw)
startlines <- grep("\\@[a-z]+{\\s*$", raw)
startlines <- grep("\\@[a-z]+\\{\\s*$", raw)
raw[startlines]
startlines <- ifelse(grepl("^\\@", raw[startlines]), raw[startlines],
gsub("^.*\\@", "@", raw[startlines]))
raw[startlines]
raw[startlines] <- ifelse(grepl("^\\@", raw[startlines]), raw[startlines],
gsub("^.*\\@", "@", raw[startlines]))
startlines <- grep("\\@[a-z]+\\{\\s*$", raw)
raw[startlines] <- ifelse(grepl("^\\@", raw[startlines]), raw[startlines],
gsub("^.*\\@", "@", raw[startlines]))
raw[startlines]
raw <- readLines("AP-Bibtex.txt")
startlines <- grep("\\@[a-z]+\\{\\s*$", raw)
raw[startlines] <- ifelse(grepl("^\\@", raw[startlines]),
raw[startlines],
gsub("^.*\\@", "@", raw[startlines]))
endlines <- grep("^}$", raw)
clean <- raw
gsub("=", "aa", "a=b")
authorlines <- grep("^\\s*(author)\\s*=", raw, ignore.case = TRUE)
yearlines <- grep("^\\s*(year)\\s*=", raw, ignore.case = TRUE)
seq_along(2,2+5)
seq(2,2+5)
paste("5", NA)
key_chain <- character(length(raw))
?toupper
key_chain <- character(length(startlines))
source('~/.active-rstudio-document', echo=TRUE)
warnings()
clean[1:10]
group_author
i <- 2
startlines <- grep("\\@[a-z]+\\{\\s*$", raw)
i <- startlines[1]
next_endline <- min(endlines[endlines > i])
next_authorline <- min(authorlines[authorlines > i & next_endline < i])
next_yearline   <- min(yearlines[yearlines > i & next_endline < i])
authorlines
authorlines > i
next_endline
head(authorlines)
authorlines[authorlines > i & next_endline < i]
i
2 > i
8 < i
next_authorline <- min(authorlines[authorlines > i & authorlines < next_endline])
next_yearline   <- min(yearlines[yearlines > i & yearlines < next_endline])
next_authorline
next_yearline
raw[next_yearline]
group_year <- gsub("^.*\\{([12][0-9]{1,3})\\}.*$", "\\1", raw[next_yearline])
group_year
i
next_endline <- min(endlines[endlines > i])
next_authorline <- min(authorlines[authorlines > i & authorlines < next_endline])
next_yearline   <- min(yearlines[yearlines > i & yearlines < next_endline])
if (!is.na(next_authorline)){
group_author <- gsub("\\{([a-zA-z\\s])\\}", "\\1", raw[next_authorline])
group_author <- tolower(group_author)
} else {
group_author <- "noauthor"
}
if (!is.na(next_yearline))
group_year <- gsub("^.*\\{([12][0-9]{1,3})\\}.*$", "\\1", raw[next_yearline])
else
if (!is.na(next_yearline)){
group_year <- gsub("^.*\\{([12][0-9]{1,3})\\}.*$", "\\1", raw[next_yearline])
} else {
group_year <- "nd"
}
plausible_key <- paste0(group_author, group_year)
if(plausible_key %in% key_chain){
# This only occurs when the first conflict occurs. It should be
# chomsky1981a, chomsky1981b. Right now, it's chomsky1981, chomsky1981.
# This is the only possible situation.
key_siblings <- sum(key_chain == gsub("[0-9][a-z]$", "", plausible_key))
plausible_key <- paste0(plausible_key, letters[key_siblings + 1])
key_chain[i] <- paste0(plausible_key, "b")
key_chain[i - 1] <- paste0(key_chain[i - 1], "a")
} else {
# In this case, we probably have different author years, but we could also have
# Chomsky1981a, Chomsky1981b, Chomsky1981.  We need to test before proceeding.
# How many keys on the chain have the same prefix?
key_siblings <- sum(key_chain == gsub("[0-9][a-z]$", "", plausible_key))
if (key_siblings == 0)
key_chain[i] <- plausible_key
else {
plausible_key <- paste0(plausible_key, letters[key_siblings + 1])
}
}
clean[i] <- gsub("(\\@[a-z]+\\{)\\s*$", "\\1", raw[i])
clean[i] <- paste0(clean[i], plausible_key)
clean[1]
raw[1]
clean[i] <- gsub("(\\@[a-z]+\\{)\\s*$", "\\1", raw[i])
raw[1]
raw[1]
clean[1]
plausible_key
if (!is.na(next_authorline)){
group_author <- gsub("^.*\\{([a-zA-z\\s])\\}.^$", "\\1", raw[next_authorline])
group_author <- tolower(group_author)
} else {
group_author <- "noauthor"
}
plausible_key <- paste0(group_author, group_year)
plausible_key
r
r
r
if (!is.na(next_authorline)){
group_author <- gsub("^.*\\{([a-zA-z\\s]+)\\}.^$", "\\1", raw[next_authorline])
group_author <- tolower(group_author)
} else {
group_author <- "noauthor"
}
group_author
raw[next_authorline]
gsub("\\{(.*)\\}", "\\1", raw[next_authorline])
gsub("\\{([^\\{\\}]*)\\}", "\\1", raw[next_authorline])
grepl("\\{", "{azb}")
grsub("\\{(.)", "\\1", "{azb")
gsub("\\{(.)", "\\1", "{azb")
gsub("\\{(.)\\}", "\\1", "{azb}")
gsub("\\{(.)+\\}", "\\1", "{azb}")
gsub("\\{(.){3\\}", "\\1", "{azb}")
gsub("\\{(.){3|\\}", "\\1", "{azb}")
gsub("\\{(.){3}\\}", "\\1", "{azb}")
gsub("\\{[a-z]{3}\\}", "\\1", "{azb}")
gsub("\\{([a-z]{3})\\}", "\\1", "{azb}")
gsub("\\{([a-z]*)\\}", "\\1", "{azb}")
group_author <- gsub("^.*\\{([a-zA-Z\\s]+)\\}.^$", "\\1", raw[next_authorline])
group_author
group_author <- gsub("\\{([a-zA-Z]+)\\}", "\\1", raw[next_authorline])
grou_author
group_author
group_author <- tolower(raw[next_authorline])
group_author
group_author <- gsub("\\{([a-z]*)\\}", "\\1", group_author)
group_author
group_author <- tolower(raw[next_authorline])
group_author <- tolower(raw[next_authorline])
group_author <- gsub("^.*\\{([a-z]*)\\}.*$", "\\1", group_author)
i
clean <- raw
key_chain <- character(length(startlines))
for (i in seq_along(startlines)){
next_endline <- min(endlines[endlines > i])
i
next_endline <- min(endlines[endlines > i])
next_authorline <- min(authorlines[authorlines > i & authorlines < next_endline])
next_yearline   <- min(yearlines[yearlines > i & yearlines < next_endline])
if (!is.na(next_authorline)){
group_author <- tolower(raw[next_authorline])
group_author <- gsub("^.*\\{([a-z]*)\\}.*$", "\\1", group_author)
} else {
group_author <- "noauthor"
}
if (!is.na(next_yearline)){
group_year <- gsub("^.*\\{([12][0-9]{1,3})\\}.*$", "\\1", raw[next_yearline])
} else {
group_year <- "nd"
}
plausible_key <- paste0(group_author, group_year)
if(plausible_key %in% key_chain){
# This only occurs when the first conflict occurs. It should be
# chomsky1981a, chomsky1981b. Right now, it's chomsky1981, chomsky1981.
# This is the only possible situation.
key_siblings <- sum(key_chain == gsub("[0-9][a-z]$", "", plausible_key))
plausible_key <- paste0(plausible_key, letters[key_siblings + 1])
key_chain[i] <- paste0(plausible_key, "b")
key_chain[i - 1] <- paste0(key_chain[i - 1], "a")
} else {
# In this case, we probably have different author years, but we could also have
# Chomsky1981a, Chomsky1981b, Chomsky1981.  We need to test before proceeding.
# How many keys on the chain have the same prefix?
key_siblings <- sum(key_chain == gsub("[0-9][a-z]$", "", plausible_key))
if (key_siblings == 0)
key_chain[i] <- plausible_key
else {
plausible_key <- paste0(plausible_key, letters[key_siblings + 1])
}
}
clean[i] <- gsub("(\\@[a-z]+\\{)\\s*$", "\\1", raw[i])
clean[i] <- paste0(clean[i], plausible_key)
clean[1]
source('~/.active-rstudio-document', echo=TRUE)
clean[1]
clean[startlines]
source('~/.active-rstudio-document', echo=TRUE)
clean[startlines]
key_siblines
key_siblings
source('~/.active-rstudio-document', echo=TRUE)
warnings()
clean[startlines]
gsub("[0-9][a-z]$", "", plausible_key)
source('~/.active-rstudio-document', echo=TRUE)
clean[startlines]
key_chain
seq_along(startlines)
source('~/.active-rstudio-document', echo=TRUE)
key_siblings <- sum(key_chain_prefixes == gsub("([0-9])[a-z]$", "\\1", plausible_key))
key_siblings
key_chain_prefixes
key_chain
source('~/.active-rstudio-document', echo=TRUE)
key_chain
key_chain_prefixes
clean
clean[startlines]
raw <- readLines("AP-Bibtex.txt")
startlines <- grep("\\@[a-z]+\\{\\s*$", raw)
raw[startlines] <- ifelse(grepl("^\\@", raw[startlines]),
raw[startlines],
gsub("^.*\\@", "@", raw[startlines]))
authorlines <- grep("^\\s*(author)\\s*=", raw, ignore.case = TRUE)
yearlines <- grep("^\\s*(year)\\s*=", raw, ignore.case = TRUE)
endlines <- grep("^}$", raw)
clean <- raw
key_chain <- character(length(startlines))
key_chain_prefixes <- key_chain
count <- 0
for (i in startlines){
count <- count + 1
next_endline <- min(endlines[endlines > i])
next_authorline <- min(authorlines[authorlines > i & authorlines < next_endline])
next_yearline   <- min(yearlines[yearlines > i & yearlines < next_endline])
if (!is.na(next_authorline)){
group_author <- tolower(raw[next_authorline])
group_author <- gsub("^.*\\{([a-z]*).*\\}.*$", "\\1", group_author)
} else {
group_author <- "noauthor"
}
if (!is.na(next_yearline)){
group_year <- gsub("^.*\\{([12][0-9]{1,3})\\}.*$", "\\1", raw[next_yearline])
} else {
group_year <- "nd"
}
plausible_key <- paste0(group_author, group_year)
if(plausible_key %in% key_chain){
# This only occurs when the first conflict occurs. It should be
# chomsky1981a, chomsky1981b. Right now, it's chomsky1981, chomsky1981.
# This is the only possible situation.
key_siblings <- sum(key_chain == gsub("[0-9][a-z]$", "", plausible_key))
plausible_key <- paste0(plausible_key, letters[key_siblings + 1])
key_chain[count] <- paste0(plausible_key, "b")
key_chain[count - 1] <- paste0(key_chain[count - 1], "a")
key_chain_prefixes <- gsub("[a-z]$", "", key_chain)
} else {
# In this case, we probably have different author years, but we could also have
# Chomsky1981a, Chomsky1981b, Chomsky1981.  We need to test before proceeding.
# How many keys on the chain have the same prefix?
key_chain_prefixes <- gsub("[a-z]$", "", key_chain)
key_siblings <- sum(key_chain_prefixes == gsub("([0-9])[a-z]$", "\\1", plausible_key))
if (key_siblings == 0){
key_chain[count] <- plausible_key
} else {
plausible_key <- paste0(plausible_key, letters[key_siblings + 1])
}
}
clean[i] <- gsub("(\\@[a-z]+\\{)\\s*$", "\\1", raw[i])
clean[i] <- paste0(clean[i], plausible_key, ",")
}
search()
remove.packages("grattan")
devtools::install_github("HughParsonage/grattan")
clean[startlines]
remove.packages("grattan")
devtools::install_github("HughParsonage/grattan")
library(grattan)
zzz.R
?zzz
??zzz
grattan:::zzz
?grattan:::zzz
my_emf
70*1.025
71.75*1.025
71.75*1.0275
71.75*1.03
73.73*1.0275
75*1.03
income_tax(43178)
library(grattan)
income_tax(43178)
income_tax(57447)
remove.packages("grattan");devtools::install_github("HughParsonage/grattan")
remove.packages("grattan")
library(devtools)
install_github("HughParsonage/github")
install_github("HughParsonage/github")
install_github("HughParsonage/grattan")
devtools::install_github("HughParsonage/grattan")
new.discount <- 0.3
taxstats201213 %>%
# Reduce CGT discount to 30%
mutate(
new_capital_gains = 2 * Net_CG_amt * (1 - new.discount),
Taxable_Income_No_CG_discount = Taxable_Income - Net_CG_amt + new_capital_gains,
## is this right? -- BC: Glanced and corrected Net_rent_amt sign.
Taxable_Income_new_proposal = ifelse(Net_rent_amt < 0,
pmax(0, Taxable_Income_No_CG_discount - Sw_amt + Net_rent_amt) + Sw_amt,
Taxable_Income_No_CG_discount),
loss_carry_fwd = pmin(0,Taxable_Income_No_CG_discount - Sw_amt + Net_rent_amt),
current_tax = income_tax(Taxable_Income),
new_tax = income_tax(Taxable_Income_new_proposal),
new_tax_with_carry_fwd = income_tax(Taxable_Income_new_proposal + loss_carry_fwd)
diff = new_tax - current_tax
) %$%
sum(diff) * 50 / 1e9 ->
reduce_cgt_limit_negative_gearing_costing
print(reduce_cgt_limit_negative_gearing_costing)
daley_taxstats <-
taxstats201213 %>%
mutate(
new_capital_gains = 2 * Net_CG_amt * (1 - new.discount),
Taxable_Income_Red_CG_discount = Taxable_Income - Net_CG_amt + new_capital_gains,
new_net_rent = ifelse(discount_only_to_negative_rent_income,
Net_rent_amt * (1 - new.discount * (Net_rent_amt < 0)),  # discount only to negative income
Net_rent_amt * (1 - new.discount)),
new_tot_inc = Tot_inc_amt - Net_CG_amt + new_capital_gains,
income_no_salary = pmax(Tot_inc_amt - Sw_amt, 0),  # positive component of income not from salary
#
# This is not quite true: it doesn't include medical offsets.
new_Taxable_Income = ifelse(Net_rent_amt < 0,
pmax(0, income_no_salary + Net_rent_amt) + Sw_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed,
income_no_salary + Sw_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed),
loss_carry_fwd = -1 * pmin(0, income_no_salary + Net_rent_amt),
#
# Ratio of (new?) capital gains to losses is the proportion of each taxpayer's
# capital gains that may be deducted from the rental losses which, due
# to the abolition of negative gearing in this proposal, cannot be immediately
# deducted from one's income.  The sums represent the overall ratio in the population
# which we assume to be constant year-on-year.
annualized_loss = abs(sum(new_capital_gains) / sum(loss_carry_fwd)) * loss_carry_fwd,  # nonnegative
new_Taxable_Income_post_carryfwd = new_Taxable_Income - annualized_loss,  # remembering ann.lss is nonnegative
current_tax = income_tax(Taxable_Income),
new_tax = income_tax(new_Taxable_Income_post_carryfwd),
diff = new_tax - current_tax
)
if (discount_only_to_negative_rent_income){
daley_discount_remark <- "in which the discount is only applied to rental losses (not rental income, contra Henry)"
} else {
daley_discount_remark <- "in which the discount is applied to both rental income and rental losses"
}
source('~/.active-rstudio-document', echo=TRUE)
setwd("C:/Users/hparsonage/Dropbox/Budget Repair Report/Data and analysis/CGT/Negative_gearing")
source('~/.active-rstudio-document', echo=TRUE)
daley_taxstats <-
taxstats201213 %>%
mutate(
new_capital_gains = 2 * Net_CG_amt * (1 - new.discount),
Taxable_Income_Red_CG_discount = Taxable_Income - Net_CG_amt + new_capital_gains,
new_net_rent = ifelse(discount_only_to_negative_rent_income,
Net_rent_amt * (1 - new.discount * (Net_rent_amt < 0)),  # discount only to negative income
Net_rent_amt * (1 - new.discount)),
new_tot_inc = Tot_inc_amt - Net_CG_amt + new_capital_gains,
income_no_salary = pmax(Tot_inc_amt - Sw_amt, 0),  # positive component of income not from salary
#
# This is not quite true: it doesn't include medical offsets.
new_Taxable_Income = ifelse(Net_rent_amt < 0,
pmax(0, income_no_salary + Net_rent_amt) + Sw_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed,
income_no_salary + Sw_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed),
loss_carry_fwd = -1 * pmin(0, income_no_salary + Net_rent_amt),
#
# Ratio of (new?) capital gains to losses is the proportion of each taxpayer's
# capital gains that may be deducted from the rental losses which, due
# to the abolition of negative gearing in this proposal, cannot be immediately
# deducted from one's income.  The sums represent the overall ratio in the population
# which we assume to be constant year-on-year.
annualized_loss = abs(sum(new_capital_gains) / sum(loss_carry_fwd)) * loss_carry_fwd,  # nonnegative
new_Taxable_Income_post_carryfwd = new_Taxable_Income - annualized_loss,  # remembering ann.lss is nonnegative
current_tax = income_tax(Taxable_Income),
new_tax = income_tax(new_Taxable_Income_post_carryfwd),
diff = new_tax - current_tax
)
if (discount_only_to_negative_rent_income){
daley_discount_remark <- "in which the discount is only applied to rental losses (not rental income, contra Henry)"
} else {
daley_discount_remark <- "in which the discount is applied to both rental income and rental losses"
}
new.discount <- 0.30
discount_only_to_negative_rent_income <- TRUE
daley_taxstats <-
taxstats201213 %>%
mutate(
new_capital_gains = 2 * Net_CG_amt * (1 - new.discount),
Taxable_Income_Red_CG_discount = Taxable_Income - Net_CG_amt + new_capital_gains,
new_net_rent = ifelse(discount_only_to_negative_rent_income,
Net_rent_amt * (1 - new.discount * (Net_rent_amt < 0)),  # discount only to negative income
Net_rent_amt * (1 - new.discount)),
new_tot_inc = Tot_inc_amt - Net_CG_amt + new_capital_gains,
income_no_salary = pmax(Tot_inc_amt - Sw_amt, 0),  # positive component of income not from salary
#
# This is not quite true: it doesn't include medical offsets.
new_Taxable_Income = ifelse(Net_rent_amt < 0,
pmax(0, income_no_salary + Net_rent_amt) + Sw_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed,
income_no_salary + Sw_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed),
loss_carry_fwd = -1 * pmin(0, income_no_salary + Net_rent_amt),
#
# Ratio of (new?) capital gains to losses is the proportion of each taxpayer's
# capital gains that may be deducted from the rental losses which, due
# to the abolition of negative gearing in this proposal, cannot be immediately
# deducted from one's income.  The sums represent the overall ratio in the population
# which we assume to be constant year-on-year.
annualized_loss = abs(sum(new_capital_gains) / sum(loss_carry_fwd)) * loss_carry_fwd,  # nonnegative
new_Taxable_Income_post_carryfwd = new_Taxable_Income - annualized_loss,  # remembering ann.lss is nonnegative
current_tax = income_tax(Taxable_Income),
new_tax = income_tax(new_Taxable_Income_post_carryfwd),
diff = new_tax - current_tax
)
if (discount_only_to_negative_rent_income){
daley_discount_remark <- "in which the discount is only applied to rental losses (not rental income, contra Henry)"
} else {
daley_discount_remark <- "in which the discount is applied to both rental income and rental losses"
}
sum(daley_taxstats$diff) * 50 / 1e9
daley_taxstats %>% select(Sw_amt, Taxable_Income, new_Taxable_Income_post_carryfwd)
daley_taxstats %>% select(Sw_amt, Taxable_Income, new_Taxable_Income, new_Taxable_Income_post_carryfwd)
daley_taxstats %>% mutate(pmax(0,income_no_salary + Net_rent_amt))

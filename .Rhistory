# 7       TRUE    TRUE FALSE  14724 0.378
# 8       TRUE    TRUE  TRUE   1143 0.029
prob_of_noCG_if_investor <- capital_gains_by_losses4 %>%
filter(IsInvestor, !HasCG) %$%
sum(prop)
for (i in 1:eventual){
if (i == 1){
new_daley <-
daley_taxstats %>%
# random
mutate(loss_carry_fwd_orig = loss_ignore_CG) %>%
mutate(hasHadCG = FALSE,  #yet
whenCG.lastoccurred = 0,
prev_unexhausted_loss = loss_ignore_CG)
}
gc()
new_daley %<>%
mutate(rand = runif(nrow(.))) %>%
mutate(noCGevent = rand < prob_of_noCG_if_investor) %>%
mutate(HasCG = !noCGevent) %>%
merge(taxable_income_by_CG, by = "HasCG")  %>%
mutate(
# We act on the new_tax directly.If someone has a CG event,
# we bring forward all their losses thitherto and reduce their tax
# by the average marginal tax rate for someone who earned capital gains
new_tax = ifelse(noCGevent,
income_tax(new_Taxable_Income, fy.year = fy.year),
# Should negative taxes be included? Answer not yet obvious.
pmax(0, income_tax(new_Taxable_Income, fy.year = fy.year) - marginal.tax.of.avg * loss_carry_fwd_orig * (i - whenCG.lastoccurred))),
diff = new_tax - current_tax,
# record for console printout
whenCG.lastoccurred.prev = whenCG.lastoccurred,
# reset if applicable
whenCG.lastoccurred = ifelse(!noCGevent, i, whenCG.lastoccurred),
hasHadCG = as.logical(pmin(hasHadCG + !noCGevent, 1))
) %>%
select(-marginal.tax.of.avg) %>%
data.table
setTxtProgressBar(progress_bar, value = i)
close(progress_bar)
if(i == eventual){
cat("\n")
}
}
#   return({
#     data.table(Year = year,
#                Initial_revenue_diff = sum(daley_taxstats$diff)*weighting(year)/1e9,
#                Eventual_revenue_diff = sum(new_daley$diff)*weighting(year)/1e9,
#                eventual_means... = paste("After", eventual, "years"),
#                Diff_due_CG = sum(daley_taxstats$tax_after_reduction_in_discount - daley_taxstats$current_tax)*weighting(year)/1e9
#     )
#   })
new_daley
}
cost_of_daley_policy_fast <- function(year = 2013, eventual = 20, CGT.discount = 0.30){
fy.year <- yr2fy(year)
if (year >= 2014){
# Inflate the wages for future years.
# Adjust the variables which depend on Sw_amt
# accordingly (otherwise the difference just becomes smaller).
daley_taxstats <-
fread(sample_file_of(2013)) %>%
mutate(
Taxable_Income = Taxable_Income - Sw_amt + Sw_amt * (wage_inflator(from_fy = "2012-13", to_fy = "2013-14"))^(year - 2013),
Tot_inc_amt = Tot_inc_amt - Sw_amt + Sw_amt * (wage_inflator(from_fy = "2012-13", to_fy = "2013-14"))^(year - 2013),
Sw_amt = Sw_amt * (wage_inflator(from_fy = "2012-13", to_fy = "2013-14"))^(year - 2013)
)
} else {
daley_taxstats <-
# fread(sample_file_of(2013)) %>%
fread(sample_file_of(year = year))
}
# Year specific housekeeping
# Before 2011-12, there is no variable Net_fincl_lss_amt
if (!("Net_fincl_invstmt_lss_amt" %in% names(daley_taxstats)))
daley_taxstats[,Net_fincl_invstmt_lss_amt := 0]
if (!("ETP_txbl_amt" %in% names(daley_taxstats)))
daley_taxstats[,ETP_txbl_amt := 0]
prop_full_discount <-
get_sample_file(2013) %>%
filter(Net_CG_amt > 0) %>%
mutate(apparent.discount = round(2*Net_CG_amt/Tot_CY_CG_amt)/2,
apparent.discount = ifelse(abs(apparent.discount - 0.5) <= 0.02, 0.50, apparent.discount)) %>%
group_by(apparent.discount) %>%
tally() %>%
arrange(n) %>%
ungroup %>%
filter(apparent.discount %in% c(0.5,1)) %>%
mutate(n.p = n/sum(n),
discount.key = cumsum(n.p))
# More things to consider
# This is a problem.
#   get_sample_file(2013) %>%
#     filter(Net_CG_amt > 0) %>%
#     mutate(discount = Net_CG_amt / Tot_CY_CG_amt,
#            tax.bracket = cut(Taxable_Income, breaks = c(-1,182e2, 37e3, 80e3, 180e3, Inf))) %>%
#     grplot(aes(x = discount, y = Net_CG_amt)) +
#     geom_point() +
#     coord_cartesian(ylim = c(1e4,1e6)) +
#     scale_y_continuous(label = grattan_dollar) +
#     facet_grid(tax.bracket~.)
daley_taxstats %<>%
#
# One silly entry has a CG of $25M!
filter(Net_CG_amt < 5e6) %>%
# These next steps attempt to estimate the size of the typical discount.
# Previously, we assumed that all capital gains events enjoyed the full 50%
# discount. This was erroneous, but thought not to be a major problem. It is
# somewhat of a problem.
#
#   get_sample_file(2013) %>%
#     filter(Net_CG_amt > 0) %>%
#     mutate(discount = Net_CG_amt / Tot_CY_CG_amt) %>%
#     grplot(aes(x = discount, y = Net_CG_amt)) +
#     geom_point() +
#     coord_cartesian(ylim = c(1e4,1e6)) +  scale_y_continuous(label = grattan_dollar)
#
#
# so we estimate the number of capital gains events at each discount 0%, 10%, 20%, 30%,
# based on Net capital gains / Total capital gains.
# It's important to note
# that this is polluted by losses carried forward.
#
# The dice roll.
mutate(randCG = runif(nrow(.)))
#
# http://stackoverflow.com/questions/31490534/conditional-join-in-r#31492015
#
prop_full_discount %<>% arrange(discount.key)
ind <- findInterval(daley_taxstats$randCG, prop_full_discount$discount.key) + 1
daley_taxstats$apparent.discount <- prop_full_discount$apparent.discount[ind]
daley_taxstats %<>%
# avoid NaNs when we 1/apparent.discount
mutate(apparent.discount = ifelse(apparent.discount < 0.1, 0.05, apparent.discount)) %>%
mutate(
# Adjust the capital gains.The Net_CG_amt = (Gross CG - Losses) discounted by 50%,
# if the discount applies.But we use the apparent discount to adjust it, based on the
# dice roll.
new_capital_gains = (1/apparent.discount) * Net_CG_amt * (1 - CGT.discount),
Taxable_Income_Red_CG_discount = Taxable_Income - Net_CG_amt + new_capital_gains,
new_tot_inc = Tot_inc_amt - Net_CG_amt + new_capital_gains,
# component of income from neither salary nor rent
income_no_salary = new_tot_inc - Net_rent_amt - Sw_amt - Alow_ben_amt - ETP_txbl_amt,
#
# This is not quite true: it doesn't include medical offsets.
# You can only deduct Net_rent down to zero.
# Include financial losses in deductions
# Full tax on Sw_amt. Then deductions
new_Taxable_Income =  pmax(0, income_no_salary + Net_rent_amt - Net_fincl_invstmt_lss_amt) + Sw_amt + Alow_ben_amt + ETP_txbl_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed,
old_Taxable_Income_no_offset = Tot_inc_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed,
loss_ignore_CG = -1 * pmin(0, pmax(0, income_no_salary - new_capital_gains) + Net_rent_amt),
#
loss_carry_fwd = -1 * pmin(0, income_no_salary + Net_rent_amt),
loss_carry_fwd_not_CG = ifelse(new_capital_gains > abs(Net_rent_amt) & Net_rent_amt < 0, Net_rent_amt, 0),
#
# Ratio of (new?) capital gains to losses is the proportion of each taxpayer's
# capital gains that may be deducted from the rental losses which, due
# to the abolition of negative gearing in this proposal, cannot be immediately
# deducted from one's income.The sums represent the overall ratio in the population
# which we assume to be constant year-on-year.
#
# pmin sinces can't claim more than your losses
annualized_loss = pmin(1, abs(sum(new_capital_gains) / sum(loss_carry_fwd))) * loss_carry_fwd,  # nonnegative
#
# The consequence of the following calc is that some new_Taxable_Income_post_carryfwd will be NEGATIVE
# -- i.e.unexhausted (especially if the Taxable_Income (originally) was zero).This error will
# overestimate the amount of extra tax collected.However
#
#   daley_taxstats %>%
#     filter(new_Taxable_Income_post_carryfwd < 0) %$% sum(new_Taxable_Income) * 50 / 1e9
#   # [1] 0.224  # 224 million in losses
#
# i.e.There are at most 224 million dollars in losses carried forward that are unaccounted for
# in this model.And so at most 224 * 0.485 = 109 million in taxable income AT MOST that is
# possibly lost. My doona is comfy: I'm staying in bed for that.
new_Taxable_Income_post_carryfwd = new_Taxable_Income - annualized_loss,  # remembering ann.lss is nonnegative
current_tax = income_tax(old_Taxable_Income_no_offset, fy.year= fy.year),
tax_after_reduction_in_discount = income_tax(Taxable_Income_Red_CG_discount, fy.year = fy.year),
new_tax = income_tax(new_Taxable_Income, fy.year = fy.year),
diff = new_tax - current_tax,
diff_incl_carry_fwd = income_tax(new_Taxable_Income_post_carryfwd, fy.year = fy.year) - current_tax
#
# retrospective action
)
taxable_income_by_CG <-
daley_taxstats %>%
group_by(HasCG = new_capital_gains > 0) %>%
summarise(mean.tx.i = mean(new_Taxable_Income)) %>%
mutate(mean.tx = income_tax(mean.tx.i, fy.year = fy.year),
marginal.tax.of.avg = income_tax(mean.tx.i, fy.year = fy.year) - income_tax(mean.tx.i - 1, fy.year = fy.year)) %>%
select(HasCG, marginal.tax.of.avg) %>%
data.table
capital_gains_by_losses4 <-
daley_taxstats %>%
group_by(IsInvestor = Gross_rent_amt > 0,
HasLoss = loss_ignore_CG > 0,
HasCG = new_capital_gains > 0) %>%
tally %>%
arrange(IsInvestor, HasLoss, HasCG) %>%
#
# cosmetics:
ungroup %>%
group_by(IsInvestor) %>%
mutate(prop = round(n/sum(n),3))
# 2012-13 data
# Source: local data table [8 x 5]
#
#   IsInvestor HasLoss HasCG      n  prop
# 1      FALSE   FALSE FALSE 208423 0.968
# 2      FALSE   FALSE  TRUE   6656 0.031
# 3      FALSE    TRUE FALSE    256 0.001
# 4      FALSE    TRUE  TRUE     23 0.000
#--
# 5       TRUE   FALSE FALSE  20753 0.533
# 6       TRUE   FALSE  TRUE   2340 0.060
# 7       TRUE    TRUE FALSE  14724 0.378
# 8       TRUE    TRUE  TRUE   1143 0.029
prob_of_noCG_if_investor <- capital_gains_by_losses4 %>%
filter(IsInvestor, !HasCG) %$%
sum(prop)
for (i in 1:eventual){
if (i == 1){
new_daley <-
daley_taxstats %>%
# random
mutate(loss_carry_fwd_orig = loss_ignore_CG) %>%
mutate(hasHadCG = FALSE,  #yet
whenCG.lastoccurred = 0,
prev_unexhausted_loss = loss_ignore_CG)
}
gc()
new_daley %<>%
mutate(rand = runif(nrow(.))) %>%
mutate(noCGevent = rand < prob_of_noCG_if_investor) %>%
mutate(HasCG = !noCGevent) %>%
merge(taxable_income_by_CG, by = "HasCG")  %>%
mutate(
# We act on the new_tax directly.If someone has a CG event,
# we bring forward all their losses thitherto and reduce their tax
# by the average marginal tax rate for someone who earned capital gains
new_tax = ifelse(noCGevent,
income_tax(new_Taxable_Income, fy.year = fy.year),
# Should negative taxes be included? Answer not yet obvious.
pmax(0, income_tax(new_Taxable_Income, fy.year = fy.year) - marginal.tax.of.avg * loss_carry_fwd_orig * (i - whenCG.lastoccurred))),
diff = new_tax - current_tax,
# record for console printout
whenCG.lastoccurred.prev = whenCG.lastoccurred,
# reset if applicable
whenCG.lastoccurred = ifelse(!noCGevent, i, whenCG.lastoccurred),
hasHadCG = as.logical(pmin(hasHadCG + !noCGevent, 1))
) %>%
select(-marginal.tax.of.avg) %>%
data.table
}
#   return({
#     data.table(Year = year,
#                Initial_revenue_diff = sum(daley_taxstats$diff)*weighting(year)/1e9,
#                Eventual_revenue_diff = sum(new_daley$diff)*weighting(year)/1e9,
#                eventual_means... = paste("After", eventual, "years"),
#                Diff_due_CG = sum(daley_taxstats$tax_after_reduction_in_discount - daley_taxstats$current_tax)*weighting(year)/1e9
#     )
#   })
new_daley
}
cost_of_daley_policy_fast2 <- function(year = 2013, eventual = 20, CGT.discount = 0.30){
fy.year <- yr2fy(year)
if (year >= 2014){
# Inflate the wages for future years.
# Adjust the variables which depend on Sw_amt
# accordingly (otherwise the difference just becomes smaller).
daley_taxstats <-
fread(sample_file_of(2013)) %>%
mutate(
Taxable_Income = Taxable_Income - Sw_amt + Sw_amt * (wage_inflator(from_fy = "2012-13", to_fy = "2013-14"))^(year - 2013),
Tot_inc_amt = Tot_inc_amt - Sw_amt + Sw_amt * (wage_inflator(from_fy = "2012-13", to_fy = "2013-14"))^(year - 2013),
Sw_amt = Sw_amt * (wage_inflator(from_fy = "2012-13", to_fy = "2013-14"))^(year - 2013)
)
} else {
daley_taxstats <-
# fread(sample_file_of(2013)) %>%
fread(sample_file_of(year = year))
}
# Year specific housekeeping
# Before 2011-12, there is no variable Net_fincl_lss_amt
if (!("Net_fincl_invstmt_lss_amt" %in% names(daley_taxstats)))
daley_taxstats[,Net_fincl_invstmt_lss_amt := 0]
if (!("ETP_txbl_amt" %in% names(daley_taxstats)))
daley_taxstats[,ETP_txbl_amt := 0]
prop_full_discount <-
get_sample_file(2013) %>%
filter(Net_CG_amt > 0) %>%
mutate(apparent.discount = round(2*Net_CG_amt/Tot_CY_CG_amt)/2,
apparent.discount = ifelse(abs(apparent.discount - 0.5) <= 0.02, 0.50, apparent.discount)) %>%
group_by(apparent.discount) %>%
tally() %>%
arrange(n) %>%
ungroup %>%
filter(apparent.discount %in% c(0.5,1)) %>%
mutate(n.p = n/sum(n),
discount.key = cumsum(n.p))
# More things to consider
# This is a problem.
#   get_sample_file(2013) %>%
#     filter(Net_CG_amt > 0) %>%
#     mutate(discount = Net_CG_amt / Tot_CY_CG_amt,
#            tax.bracket = cut(Taxable_Income, breaks = c(-1,182e2, 37e3, 80e3, 180e3, Inf))) %>%
#     grplot(aes(x = discount, y = Net_CG_amt)) +
#     geom_point() +
#     coord_cartesian(ylim = c(1e4,1e6)) +
#     scale_y_continuous(label = grattan_dollar) +
#     facet_grid(tax.bracket~.)
daley_taxstats %<>%
#
# One silly entry has a CG of $25M!
filter(Net_CG_amt < 5e6)
# These next steps attempt to estimate the size of the typical discount.
# Previously, we assumed that all capital gains events enjoyed the full 50%
# discount. This was erroneous, but thought not to be a major problem. It is
# somewhat of a problem.
#
#   get_sample_file(2013) %>%
#     filter(Net_CG_amt > 0) %>%
#     mutate(discount = Net_CG_amt / Tot_CY_CG_amt) %>%
#     grplot(aes(x = discount, y = Net_CG_amt)) +
#     geom_point() +
#     coord_cartesian(ylim = c(1e4,1e6)) +  scale_y_continuous(label = grattan_dollar)
#
#
# so we estimate the number of capital gains events at each discount 0%, 10%, 20%, 30%,
# based on Net capital gains / Total capital gains.
# It's important to note
# that this is polluted by losses carried forward.
#
# The dice roll.
#
# http://stackoverflow.com/questions/31490534/conditional-join-in-r#31492015
#
daley_taxstats[,randCG := runif(nrow(daley_taxstats))]
setkey(daley_taxstats, randCG)
setkey(prop_full_discount, discount.key)
# Conditional join
daley_taxstats <- prop_full_discount[daley_taxstats, roll=-Inf]
daley_taxstats %<>%
# avoid NaNs when we 1/apparent.discount
mutate(apparent.discount = ifelse(apparent.discount < 0.1, 0.05, apparent.discount)) %>%
mutate(
# Adjust the capital gains.The Net_CG_amt = (Gross CG - Losses) discounted by 50%,
# if the discount applies.But we use the apparent discount to adjust it, based on the
# dice roll.
new_capital_gains = (1/apparent.discount) * Net_CG_amt * (1 - CGT.discount),
Taxable_Income_Red_CG_discount = Taxable_Income - Net_CG_amt + new_capital_gains,
new_tot_inc = Tot_inc_amt - Net_CG_amt + new_capital_gains,
# component of income from neither salary nor rent
income_no_salary = new_tot_inc - Net_rent_amt - Sw_amt - Alow_ben_amt - ETP_txbl_amt,
#
# This is not quite true: it doesn't include medical offsets.
# You can only deduct Net_rent down to zero.
# Include financial losses in deductions
# Full tax on Sw_amt. Then deductions
new_Taxable_Income =  pmax(0, income_no_salary + Net_rent_amt - Net_fincl_invstmt_lss_amt) + Sw_amt + Alow_ben_amt + ETP_txbl_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed,
old_Taxable_Income_no_offset = Tot_inc_amt - Tot_ded_amt - PP_loss_claimed - NPP_loss_claimed,
loss_ignore_CG = -1 * pmin(0, pmax(0, income_no_salary - new_capital_gains) + Net_rent_amt),
#
loss_carry_fwd = -1 * pmin(0, income_no_salary + Net_rent_amt),
loss_carry_fwd_not_CG = ifelse(new_capital_gains > abs(Net_rent_amt) & Net_rent_amt < 0, Net_rent_amt, 0),
#
# Ratio of (new?) capital gains to losses is the proportion of each taxpayer's
# capital gains that may be deducted from the rental losses which, due
# to the abolition of negative gearing in this proposal, cannot be immediately
# deducted from one's income.The sums represent the overall ratio in the population
# which we assume to be constant year-on-year.
#
# pmin sinces can't claim more than your losses
annualized_loss = pmin(1, abs(sum(new_capital_gains) / sum(loss_carry_fwd))) * loss_carry_fwd,  # nonnegative
#
# The consequence of the following calc is that some new_Taxable_Income_post_carryfwd will be NEGATIVE
# -- i.e.unexhausted (especially if the Taxable_Income (originally) was zero).This error will
# overestimate the amount of extra tax collected.However
#
#   daley_taxstats %>%
#     filter(new_Taxable_Income_post_carryfwd < 0) %$% sum(new_Taxable_Income) * 50 / 1e9
#   # [1] 0.224  # 224 million in losses
#
# i.e.There are at most 224 million dollars in losses carried forward that are unaccounted for
# in this model.And so at most 224 * 0.485 = 109 million in taxable income AT MOST that is
# possibly lost. My doona is comfy: I'm staying in bed for that.
new_Taxable_Income_post_carryfwd = new_Taxable_Income - annualized_loss,  # remembering ann.lss is nonnegative
current_tax = income_tax(old_Taxable_Income_no_offset, fy.year= fy.year),
tax_after_reduction_in_discount = income_tax(Taxable_Income_Red_CG_discount, fy.year = fy.year),
new_tax = income_tax(new_Taxable_Income, fy.year = fy.year),
diff = new_tax - current_tax,
diff_incl_carry_fwd = income_tax(new_Taxable_Income_post_carryfwd, fy.year = fy.year) - current_tax
#
# retrospective action
)
taxable_income_by_CG <-
daley_taxstats %>%
group_by(HasCG = new_capital_gains > 0) %>%
summarise(mean.tx.i = mean(new_Taxable_Income)) %>%
mutate(mean.tx = income_tax(mean.tx.i, fy.year = fy.year),
marginal.tax.of.avg = income_tax(mean.tx.i, fy.year = fy.year) - income_tax(mean.tx.i - 1, fy.year = fy.year)) %>%
select(HasCG, marginal.tax.of.avg) %>%
data.table
capital_gains_by_losses4 <-
daley_taxstats %>%
group_by(IsInvestor = Gross_rent_amt > 0,
HasLoss = loss_ignore_CG > 0,
HasCG = new_capital_gains > 0) %>%
tally %>%
arrange(IsInvestor, HasLoss, HasCG) %>%
#
# cosmetics:
ungroup %>%
group_by(IsInvestor) %>%
mutate(prop = round(n/sum(n),3))
# 2012-13 data
# Source: local data table [8 x 5]
#
#   IsInvestor HasLoss HasCG      n  prop
# 1      FALSE   FALSE FALSE 208423 0.968
# 2      FALSE   FALSE  TRUE   6656 0.031
# 3      FALSE    TRUE FALSE    256 0.001
# 4      FALSE    TRUE  TRUE     23 0.000
#--
# 5       TRUE   FALSE FALSE  20753 0.533
# 6       TRUE   FALSE  TRUE   2340 0.060
# 7       TRUE    TRUE FALSE  14724 0.378
# 8       TRUE    TRUE  TRUE   1143 0.029
prob_of_noCG_if_investor <- capital_gains_by_losses4 %>%
filter(IsInvestor, !HasCG) %$%
sum(prop)
for (i in 1:eventual){
if (i == 1){
new_daley <-
daley_taxstats %>%
# random
mutate(loss_carry_fwd_orig = loss_ignore_CG) %>%
mutate(hasHadCG = FALSE,  #yet
whenCG.lastoccurred = 0,
prev_unexhausted_loss = loss_ignore_CG)
}
gc()
new_daley %<>%
mutate(rand = runif(nrow(.))) %>%
mutate(noCGevent = rand < prob_of_noCG_if_investor) %>%
mutate(HasCG = !noCGevent) %>%
merge(taxable_income_by_CG, by = "HasCG")  %>%
mutate(
# We act on the new_tax directly.If someone has a CG event,
# we bring forward all their losses thitherto and reduce their tax
# by the average marginal tax rate for someone who earned capital gains
new_tax = ifelse(noCGevent,
income_tax(new_Taxable_Income, fy.year = fy.year),
# Should negative taxes be included? Answer not yet obvious.
pmax(0, income_tax(new_Taxable_Income, fy.year = fy.year) - marginal.tax.of.avg * loss_carry_fwd_orig * (i - whenCG.lastoccurred))),
diff = new_tax - current_tax,
# record for console printout
whenCG.lastoccurred.prev = whenCG.lastoccurred,
# reset if applicable
whenCG.lastoccurred = ifelse(!noCGevent, i, whenCG.lastoccurred),
hasHadCG = as.logical(pmin(hasHadCG + !noCGevent, 1))
) %>%
select(-marginal.tax.of.avg) %>%
data.table
}
#   return({
#     data.table(Year = year,
#                Initial_revenue_diff = sum(daley_taxstats$diff)*weighting(year)/1e9,
#                Eventual_revenue_diff = sum(new_daley$diff)*weighting(year)/1e9,
#                eventual_means... = paste("After", eventual, "years"),
#                Diff_due_CG = sum(daley_taxstats$tax_after_reduction_in_discount - daley_taxstats$current_tax)*weighting(year)/1e9
#     )
#   })
new_daley
}
system.time({xx <- cost_of_daley_policy(eventual = 10)})
system.time({xx <- cost_of_daley_policy_fast(eventual = 10)})
system.time({zz <- cost_of_daley_policy_fast2(eventual = 10)})
system.time({yy <- cost_of_daley_policy_fast(eventual = 10)})
yy %$% sum(diff)*50/1e9
xx %$% sum(diff)*50/1e9
zz %$% sum(diff)*50/1e9
get_sample_file(2013) %>%
mutate(age = 20 + (11 - age_range) * 5, age = ifelse(age <= 45, "45 or under", age)) %>%
mutate(age = factor(age, labels = c("under 45", "45-49", "50-54", "55-59", "60-64", "65-69", "70+"))) %>%
group_by(age, Income_decile = ntile(Taxable_Income, 10)) %>%
summarise(prop_cg = mean(Net_CG_amt > 0))  %T>%
chart_data %>%
grplot(aes(x = Income_decile, y = prop_cg, group=factor(age), color = factor(age), label = age)) +
theme_hugh(base_size = 24) +
annotate("segment",
x = -Inf, y = 0.10,
xend = 10, yend = 0.10,
color = '#DADADA') +
annotate("segment",
x = -Inf, y = 0.20,
xend = 10, yend = 0.20,
color = '#DADADA') +
annotate("segment",
x = -Inf, y = 0.30,
xend = 10, yend = 0.30,
color = '#DADADA') +
geom_dl(method = list("last.points", fontface = "bold", dl.trans(x=x+0.1), cex = 1.6)) +
scale_x_continuous(expand = c(0,0.2), breaks = 1:10, labels = c(1:4, "5\nIncome decile", 6:10)) +
annotate("blank", x = 11.5, y = 0.1) +
theme(axis.line.x = element_blank()) +
annotate("segment", x = 1, xend = 10, y = 0, yend = 0) +
scale_y_continuous(expand = c(0,0), label=percent, limits = c(0,0.3), breaks = c(0:3)/10 ) +
stat_smooth(size = 2.5, se = FALSE) +
scale_color_manual(values = rev(gpal(7))) +
theme(axis.title.x = element_blank(), # requires segment
panel.grid.major = element_blank()) + xlab("Income decile")

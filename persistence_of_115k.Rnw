\documentclass{grattan}

\title{Persistence of incomes}
\author{HP}

\addbibresource{bibliography.bib}

\begin{document}
\contentspage

<<knitrsettings, echo=FALSE, warning=FALSE, message=FALSE>>=
my_emf <- function(file, width, height){
  devEMF::emf(file, width=width, height=height,
              family = "Arial")
}

# if(require(extrafont) && any(grepl("Arial", extrafont::fonts()))){
#   font_import(pattern = "Arial")
#   my_pdf <- function(file, width, height){
#     pdf.options(family = "Arial")
#     pdf(file = file, width = width, height = height)
#   } 
#   theme_hugh <- function(...) {theme_hugh(...) + theme(text = element_text(family = "Arial"))}
# } else {
  my_pdf <- function(file, width, height){
    pdf(file = file, width, height = height)
  }
# }

# knitr chunk opts
# fig.width must = out.width and same for *.height
knitr::opts_chunk$set(fig.width=11.000, fig.height=7.00, 
                      out.width="11.000in", out.height="7.00in", 
                      fig.show='hide',echo=FALSE,
                      message=FALSE, warning=FALSE
                      ,cache=TRUE
                      ,dev=c('my_pdf', 'my_emf', 'png')
                      ,fig.ext = c("pdf", "emf", "png")
)
@


<<preamble>>=
library(foreign)
library(ggplot2)
library(scales)
library(grattan)
library(data.table)
library(tidyr)
library(dplyr)
library(magrittr)
@

<<load_dta, cache=FALSE, eval=FALSE, include=FALSE>>=
read_hilda_file <- 
  function(filename){
    dplyr::mutate(data.table::data.table(foreign::read.dta(filename)),
                  orig.filename = filename)
  }

enumerate.person.files <- 
  list.files(path = "./HILDA"
                    ,pattern = "^E.*dta$"  # Enumerate person
                    ,full.names = TRUE)

enumerate.person.files.names <-
  gsub("^.*/([^/]+)\\.dta$", "\\1", enumerate.person.files )

hilda_list <-
  lapply(enumerate.person.files, read_hilda_file)

names(hilda_list) <- enumerate.person.files.names

lapply(seq_along(hilda_list), function(element) readr::write_csv(hilda_list[[element]], path = paste0("./HILDA/csv/", names(hilda_list)[element], ".csv")))

@

<<load_csvs, cache=TRUE>>=
read_hilda_strip_first_letter_add_column_id <- 
  function(filename){  
    temp <- fread(filename)
    nms <- names(temp)
    # detect the prefix if it is the wave id.
    nms.prefixes <- unique(gsub("^(.).*$", "\\1", nms))
    yearid <- nms.prefixes[nms.prefixes %in% letters[1:13]]
    # we're interested in stripping the names that specify the wave id (a-m)
    setnames(temp, old = nms, new = gsub("^[a-m]", "", nms))
    temp %<>% mutate(wave = yearid)
    
    # temp.long <- filter(temp, !is.na(lnwte), lnwte > 0)
    tmp.svy.quantiles <- 
      survey::svydesign(ids = ~xwaveid, strata = ~xhhstrat, weights = ~hhwte,
                        data = temp) %>%
      survey::svyquantile(x = ~tifeftp, design = ., quantiles = (0:10)/10)
    temp %<>% mutate(tot_inc_percentile_contemporaneous = as.numeric(factor(cut(tifeftp,
                                                                                breaks = tmp.svy.quantiles[c(1,9:11)],
                                                                                include.lowest = TRUE))),
                     top_decile = tot_inc_percentile_contemporaneous == 3,
                     second_dec = tot_inc_percentile_contemporaneous == 2,
                     top_quintile = top_decile | second_dec)
                                                                 
    return(temp)
  }

hilda_list <- 
  lapply(list.files(path = "./HILDA/csv/", full.names = TRUE),
         read_hilda_strip_first_letter_add_column_id)
@

<<income_vars>>=
all_hilda <- rbindlist(hilda_list, fill = TRUE)

prop_stay_by_id <- 
  all_hilda %>%
  select(
    xwaveid
    ,wave
    ,lnwte
    ,hhwte
    ,tifefp
    ,tifefn
    ,top_decile
    ,top_quintile
  ) %>%
  filter(lnwte != 0) %>%
  group_by(xwaveid) %>%
  filter(ever_in_top_decile = sum(top_decile) > 0) %>%
  arrange(wave) %>%
  mutate(cum_topdecile = cumsum(top_decile)) %>%
  group_by(xwaveid) %>%
  mutate(first_enters_decile = lag(cum_topdecile) == 0 & top_decile,
         first_enters_decile_at = as.character(ifelse(first_enters_decile, wave, NA_character_)),
         has_entered_top_decile = as.logical(cumsum(top_decile)),
         top_quintile_after_top_decile = top_decile | (as.logical(cumsum(top_decile)) & top_quintile),
         leaves_decile = top_decile > lead(top_decile),
         leaves_quintile = top_quintile > lead(top_quintile)) %>%  #only TRUE followed by false
  group_by(xwaveid) %>%
  summarise(potential_time_in_top_decile = sum(has_entered_top_decile),
            time_in_top_decile = sum(top_decile),
            time_in_top_quintile = sum(top_quintile_after_top_decile),
            last_lnwte = last(lnwte)) 

# Note that quite a lot have na valued weights
prop_stay_by_id.narm <- 
  prop_stay_by_id %>%
  filter(complete.cases(.))

weighted.mean(prop_stay_by_id.narm$time_in_top_quintile / prop_stay_by_id.narm$potential_time_in_top_decile, prop_stay_by_id.narm$last_lnwte)
@


\end{document}